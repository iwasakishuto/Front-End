<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
<div class="nunkiru">
  <h1>Pose-Estimation</h1>
  <p>Tensorflow.js を用いて、<b>"Pose-Estimation"</b>を</p>
  <button id="switchCamera" onclick="switchFrontBackCamera()">switch Camera</button>
  <div id="video-canvas-wrapper" class="video-and-canvas" style="background-color:black;">
    <video id="video" style="z-index: 30;" playsinline muted autoplay ></video>
    <canvas id="canvas" style="z-index: 20;"></canvas>
  </div>
  <button id="predict-button" class="predict" style="margin-top:10px;" onclick="function(){is_detecting = !is_detecting;}">
    Loading Model <br><i id="loading" class="fa fa-spinner fa-spin" style="visibility: none;"></i>
  </button>
</div>
<script>
  var model, result;
  var predictition_button = document.getElementById('predict-button');
  var video = document.getElementById("video");
  var canvas = document.getElementById('canvas');
  var context = canvas.getContext('2d');
  var video_canvas_wrapper = document.getElementById('video-canvas-wrapper');
  const imageScaleFactor = 0.50;
  const flipHorizontal = false;
  const outputStride = 16;
  const imageElement = document.getElementById('cat');
  // load the posenet model
  posenet.load().then(function(pretrainedModel){
    model = pretrainedModel;
    setupCamera(isFacing=true);
  });
  // Setup WebCamera
  var isFacing = true; 
  function setupCamera(isFacing=true){
    navigator.mediaDevices.getUserMedia({
      audio: false,
      video: { facingMode: isFacing ? "environment" : "user" },
      audio: false,
    }).then(function(stream){
      video.addEventListener("loadedmetadata", function(){
        w = video.offsetWidth; h = video.offsetHeight;
        canvas.setAttribute('width', w.toString()); canvas.setAttribute('height', h.toString()); video_canvas_wrapper.style.height = h.toString()+"px";
      })
      video.srcObject = stream;
      video.addEventListener("loadeddata", prediction);
    })
  }
  // Prediction.
  var prevCompleted=true;
  const posesProperties = {
    flipHorizontal: false,
    internalResolution: 'high',
    segmentationThreshold: 0.9
  };
  function prediction(){
    if (prevCompleted) {
      prevCompleted = false;
      model.estimatePoses(canvas, posesProperties).then(function(poses) {
        processResults(canvas, poses);
        prevCompleted = true;
      });
    }
    window.requestAnimationFrame(prediction);
  }
  var showMethod="points";
  // var minConfidence=0.1;
  var minPoseConfidence=0.1;
  var minPartConfidence=0.1;
  var color="red"
  function processResults(canvas, poses){
    context.drawImage(video, 0, 0, video.offsetWidth, video.offsetHeight);
    poses.forEach(({score, keypoints}) => {
      if (score >= minPoseConfidence) {
        if (showMethod=="points") {
          drawKeypoints(keypoints, minPartConfidence, context);
        }
        if (showMethod=="skeleton") {
          drawSkeleton(keypoints, minPartConfidence, ctx);
        }
        if (showMethod=="boundingBox") {
          drawBoundingBox(keypoints, ctx);
        }
      }
    });
  }
  function drawPoint(ctx, y, x, r, color) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, 2*Math.PI);
    ctx.fillStyle = color;
    ctx.fill();
  }
  function drawPoints(ctx, points, radius, color) {
    var data = points.buffer().values;

    for (let i=0; i<data.length; i += 2) {
      const pointY = data[i];
      const pointX = data[i+1];

      if (pointX !== 0 && pointY !== 0) {
        ctx.beginPath();
        ctx.arc(pointX, pointY, radius, 0, 2*Math.PI);
        ctx.fillStyle = color;
        ctx.fill();
      }
    }
  }
  function drawKeypoints(keypoints, minConfidence, ctx, scale=1) {
    for (let i=0; i<keypoints.length; i++) {
      let keypoint = keypoints[i];
      if (keypoint.score < minConfidence) {
        continue;
      }
      let {y, x} = keypoint.position;
      drawPoint(ctx, y*scale, x*scale, 3, color);
    }
  }
  function drawBoundingBox(keypoints, ctx) {
    var boundingBox = posenet.getBoundingBox(keypoints);
    ctx.rect(boundingBox.minX, boundingBox.minY, boundingBox.maxX-boundingBox.minX, boundingBox.maxY-boundingBox.minY);
    ctx.strokeStyle = boundingBoxColor;
    ctx.stroke();
  }
</script>