var tipuesearch = {"pages":[{"title":"JS.18 ディレクトリ内の画像を全て表示する。","text":"ディレクトリ内部の画像を全て表示します。 今後 focus などを用いてラベル付けが楽にできるようにしたいと思います。 ディレクトリを選択してください。 label { font-family: \"Times New Roman\", Times, serif; font-size: 1.6em; color: white; background-color: red; padding: 6px; border-radius: 15px; } .galleryCover .galleryElements { text-align: center; display: inline; } .galleryCover { text-align: left; } img.__canvas { width: 12%; height: auto; margin: 3px; border: 5; } var DirInputTag = document.getElementById('InputFiles'); var GalleryTag = document.getElementById('gallery'); var files; var file; DirInputTag.addEventListener('change', function(e){ files = e.target.files; var img var div; for (var i=0; i<files.length; i++) { let reader = new FileReader(); reader.onload = function(e) { img = document.createElement('img'); img.setAttribute('src', e.target.result); img.className = \"__canvas\" li = document.createElement('li'); li.appendChild(img); li.className = 'galleryElements'; GalleryTag.appendChild(li) } reader.readAsDataURL(files[i]); } }); コード html < div style = 'text-align: center;' > < label for = 'InputFiles' > ディレクトリを選択してください。 < input id = \"InputFiles\" type = \"file\" webkitdirectory style = 'display:none;' > </ label > </ div > < ul id = \"gallery\" class = \"galleryCover\" > </ ul > js var DirInputTag = document . getElementById ( 'InputFiles' ); var GalleryTag = document . getElementById ( 'gallery' ); var files ; var file ; DirInputTag . addEventListener ( 'change' , function ( e ){ files = e . target . files ; var img var div ; for ( var i = 0 ; i < files . length ; i ++ ) { let reader = new FileReader (); reader . onload = function ( e ) { img = document . createElement ( 'img' ); img . setAttribute ( 'src' , e . target . result ); li = document . createElement ( 'li' ); li . appendChild ( img ); li . className = 'galleryElements' ; GalleryTag . appendChild ( li ) } reader . readAsDataURL ( files [ i ]); } });","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-18.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-18.html"},{"title":"JS.17 アノテーションデータ（バウンディングボックス）作成ツールのコード","text":"アノテーションデータ（バウンディングボックス）作成ツール のコードを簡単に解説します。 ディレクトリを受け取る これは非常に簡単で、 <input> タグに webkitdirectory と書けばそれで終了です。 < input id = \"ex1\" type = \"file\" webkitdirectory > なお、以下のようにすれば、ディレクトリの各種情報を得ることができます。 document . getElementById ( 'ex1' ). addEventListener ( 'change' , function ( e ){ dir = e . target . files ; // これでディレクトリを受け取る。 dirname = dir [ 0 ]. webkitRelativePath ; // 一つめのファイルのパス filenum = dir . length ; // ファイルの数 }); マウスの座標を可視化する。 window.addEventListener('load', function() { var ex2Canvas = document.getElementById('ex2'); var ex2Context = ex2Canvas.getContext('2d'); ex2Context.strokeStyle = \"#0082af\"; ex2Context.lineWidth = 1; function draw(x,y){ ex2Context.clearRect(0, 0, ex2Canvas.width, ex2Canvas.height); // Draw Indicator. ex2Context.beginPath(); ex2Context.moveTo(0, y); ex2Context.lineTo(ex2Canvas.width, y); ex2Context.moveTo(x, 0); ex2Context.lineTo(x, ex2Canvas.height); ex2Context.closePath(); ex2Context.stroke(); } ex2Canvas.addEventListener('mousemove', function(e) { draw(e.layerX, e.layerY); }); }); < canvas id = \"ex2\" width = \"200px\" height = \"200px\" style = \"border: 1.5px solid #000; background-color: #eee\" ></ canvas > < script > window . addEventListener ( 'load' , function () { var Canvas = document . getElementById ( 'ex2' ); var Context = Canvas . getContext ( '2d' ); Context . strokeStyle = \"#0082af\" ; Context . lineWidth = 1 ; function ex2draw ( x , y ){ Context . clearRect ( 0 , 0 , Canvas . width , Canvas . height ); // Draw Indicator. Context . beginPath (); Context . moveTo ( 0 , y ); Context . lineTo ( Canvas . width , y ); Context . moveTo ( x , 0 ); Context . lineTo ( x , Canvas . height ); Context . closePath (); Context . stroke (); } Canvas . addEventListener ( 'mousemove' , function ( e ) { ex2draw ( e . layerX , e . layerY ); }); }); </ script > <canvas> には、 Context.beginPath() から Context.closePath() までに描いたものが Context.stroke() によって描かれます。 バウンディングボックスを描く var ex3Canvas; var ex3Context; var ex3RectEdgeColor = \"#FB0\"; var ex3RectInnerColor = \"rgba(255,230,174,0.3)\"; var ex3IndicatorColor = \"#0082af\"; var ex3index=0; var ex3DrawingMemory = { 0: { x: null, y: null, w: null, h: null} }; window.addEventListener('load', function() { ex3Canvas = document.getElementById('ex3'); ex3Context = ex3Canvas.getContext('2d'); ex3Context.strokeStyle = ex3IndicatorColor; ex3Context.fillStyle = ex3RectInnerColor; ex3Context.lineWidth = 1; var ex3startPosition = { x: null, y: null }; var ex3isDrag; function ex3dragStart(x,y){ ex3isDrag=true; ex3startPosition.x = x; ex3startPosition.y = y; } function ex3dragEnd(x,y){ if (ex3isDrag){ ex3DrawingMemory[ex3index] = { x: ex3startPosition.x, y: ex3startPosition.y, w: x-ex3startPosition.x, h: y-ex3startPosition.y }; ex3index+=1; ex3ex3drawFromMemory(); }else{ ex3clear(); ex3ex3drawFromMemory(); } ex3isDrag=false; } function ex3ex3drawFromMemory(){ ex3Context.strokeStyle = ex3RectEdgeColor; for (i=0; i<ex3index; i++){ ex3Context.fillRect(ex3DrawingMemory[i].x, ex3DrawingMemory[i].y, ex3DrawingMemory[i].w, ex3DrawingMemory[i].h); } for (i=0; i<ex3index; i++){ ex3Context.strokeRect(ex3DrawingMemory[i].x, ex3DrawingMemory[i].y, ex3DrawingMemory[i].w, ex3DrawingMemory[i].h); } ex3Context.strokeStyle = ex3IndicatorColor; } function ex3draw(x,y){ ex3clear(); // Initialization. ex3ex3drawFromMemory(); // Draw Bounding Boxes. // Draw Indicator. ex3Context.beginPath(); ex3Context.moveTo(0, y); // start ex3Context.lineTo(ex3Canvas.width, y); // end ex3Context.moveTo(x, 0); // start ex3Context.lineTo(x, ex3Canvas.height); // end ex3Context.closePath(); ex3Context.stroke(); // Draw the current Bounding Box. if(ex3isDrag){ ex3Context.strokeStyle = ex3RectEdgeColor; ex3Context.fillRect(ex3startPosition.x, ex3startPosition.y, x-ex3startPosition.x, y-ex3startPosition.y); ex3Context.strokeRect(ex3startPosition.x, ex3startPosition.y, x-ex3startPosition.x, y-ex3startPosition.y); ex3Context.strokeStyle = ex3IndicatorColor; } } function ex3mouseHandler(){ ex3Canvas.addEventListener('mousedown', function(e){ ex3dragStart(e.layerX, e.layerY); }); ex3Canvas.addEventListener('mouseup', function(e){ ex3dragEnd(e.layerX, e.layerY); }); ex3Canvas.addEventListener('mouseout', function(e){ ex3dragEnd(e.layerX, e.layerY); }); ex3Canvas.addEventListener('mousemove', function(e) { ex3draw(e.layerX, e.layerY); }); } ex3mouseHandler(); }); function ex3clear(){ ex3Context.clearRect(0, 0, ex3Canvas.width, ex3Canvas.height); } < canvas id = \"ex3\" width = \"200px\" height = \"200px\" style = \"border: 1.5px solid #000; background-color: #fff\" ></ canvas > < script > var Canvas ; var Context ; var RectEdgeColor = \"#FB0\" ; var RectInnerColor = \"rgba(255,230,174,0.3)\" ; var IndicatorColor = \"#0082af\" ; var index = 0 ; var DrawingMemory = { 0 : { x : null , y : null , w : null , h : null } }; window . addEventListener ( 'load' , function () { Canvas = document . getElementById ( 'ex3' ); Context = Canvas . getContext ( '2d' ); Context . strokeStyle = IndicatorColor ; Context . fillStyle = RectInnerColor ; Context . lineWidth = 1 ; var startPosition = { x : null , y : null }; var isDrag ; function dragStart ( x , y ){ isDrag = true ; startPosition . x = x ; startPosition . y = y ; } function dragEnd ( x , y ){ if ( isDrag ){ DrawingMemory [ index ] = { x : startPosition . x , y : startPosition . y , w : x - startPosition . x , h : y - startPosition . y }; index += 1 ; drawFromMemory (); } else { clear (); drawFromMemory (); } isDrag = false ; } function drawFromMemory (){ Context . strokeStyle = RectEdgeColor ; for ( i = 0 ; i < index ; i ++ ){ Context . fillRect ( DrawingMemory [ i ]. x , DrawingMemory [ i ]. y , DrawingMemory [ i ]. w , DrawingMemory [ i ]. h ); } for ( i = 0 ; i < index ; i ++ ){ Context . strokeRect ( DrawingMemory [ i ]. x , DrawingMemory [ i ]. y , DrawingMemory [ i ]. w , DrawingMemory [ i ]. h ); } Context . strokeStyle = IndicatorColor ; } function draw ( x , y ){ clear (); // Initialization. drawFromMemory (); // Draw Bounding Boxes. // Draw Indicator. Context . beginPath (); Context . moveTo ( 0 , y ); // start Context . lineTo ( Canvas . width , y ); // end Context . moveTo ( x , 0 ); // start Context . lineTo ( x , Canvas . height ); // end Context . closePath (); Context . stroke (); // Draw the current Bounding Box. if ( isDrag ){ Context . strokeStyle = RectEdgeColor ; Context . fillRect ( startPosition . x , startPosition . y , x - startPosition . x , y - startPosition . y ); Context . strokeRect ( startPosition . x , startPosition . y , x - startPosition . x , y - startPosition . y ); Context . strokeStyle = IndicatorColor ; } } function mouseHandler (){ Canvas . addEventListener ( 'mousedown' , function ( e ){ dragStart ( e . layerX , e . layerY ); }); Canvas . addEventListener ( 'mouseup' , function ( e ){ dragEnd ( e . layerX , e . layerY ); }); Canvas . addEventListener ( 'mouseout' , function ( e ){ dragEnd ( e . layerX , e . layerY ); }); Canvas . addEventListener ( 'mousemove' , function ( e ) { draw ( e . layerX , e . layerY ); }); } mouseHandler (); }); function clear (){ Context . clearRect ( 0 , 0 , Canvas . width , Canvas . height ); } </ script > あとは、バウンディングボックスの情報を保持して、最後にラベルデータや width , height と一緒に JSON.stringify で json データにしてダウンロードすれば終了です。","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-17.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-17.html"},{"title":"JS.16 アノテーションデータ（バウンディングボックス）作成ツール","text":"U-Net で大腸菌カウンターを作るなど、 Object Detection や Semantic Segmentation のモデルを実際に作ってみたいなと思ったので、まずは バウンディングボックス のアノテーションデータ作成ツールを作りました。 今後やるべきこと 画像サイズを「固定」 or 「可変」で選べるようにする。 バウンディングボックスを取り消せるようにする。 Semantic Segmentationのデータ作成ツールを作る。 width が負の値を取るとデータの整形時に面倒なので、 to , right , bottom , left の形にする。 作ったもの NEXT Download label width px height px .canvas { position: absolute; left: 0; right: 0; margin: 30px auto; } #preview { z-index: 2; } #canvas { z-index: 3; } #space { z-index: 1; margin-top: 284px; } var Canvas; var Context; var RectEdgeColor = \"#ACFF00\"; var RectInnerColor = \"rgba(204,255,0,0.3)\"; var IndicatorColor = \"#DDD\"; var ImgTag = document.getElementById('preview'); var DirInputTag = document.getElementById('file'); var LabelTag = document.getElementById('label'); var DonwloadBtn = document.getElementById('download'); var WidthInputTag = document.getElementById('imgWidth'); var HeightInputTag = document.getElementById('imgHeight'); var SpaceDivTag = document.getElementById('space'); var fileIndex; var filenum; var files; var dirname; var index=0; var Memory = {}; var DrawingMemory = { 0: { x: null, y: null, w: null, h: null} }; window.addEventListener('load', function() { Canvas = document.getElementById('canvas'); Context = Canvas.getContext('2d'); Context.strokeStyle = IndicatorColor; Context.fillStyle = RectInnerColor; Context.lineWidth = 1; var startPosition = { x: null, y: null }; var isDrag; function dragStart(x,y){ isDrag=true; startPosition.x = x; startPosition.y = y; } function dragEnd(x,y){ if (isDrag){ DrawingMemory[index] = { x: startPosition.x, y: startPosition.y, w: x-startPosition.x, h: y-startPosition.y }; index+=1; drawFromMemory(); }else{ clear(); drawFromMemory(); } isDrag=false; } function drawFromMemory(){ Context.strokeStyle = RectEdgeColor; for (i=0; i<index; i++){ Context.fillRect(DrawingMemory[i].x, DrawingMemory[i].y, DrawingMemory[i].w, DrawingMemory[i].h); } for (i=0; i<index; i++){ Context.strokeRect(DrawingMemory[i].x, DrawingMemory[i].y, DrawingMemory[i].w, DrawingMemory[i].h); } Context.strokeStyle = IndicatorColor; } function draw(x,y){ clear(); // Initialization. drawFromMemory(); // Draw Bounding Boxes. // Draw Indicator. Context.beginPath(); Context.moveTo(0, y); // start Context.lineTo(Canvas.width, y); // end Context.moveTo(x, 0); // start Context.lineTo(x, Canvas.height); // end Context.closePath(); Context.stroke(); // Draw the current Bounding Box. if(isDrag){ Context.strokeStyle = RectEdgeColor; Context.fillRect(startPosition.x, startPosition.y, x-startPosition.x, y-startPosition.y); Context.strokeRect(startPosition.x, startPosition.y, x-startPosition.x, y-startPosition.y); Context.strokeStyle = IndicatorColor; } } function mouseHandler(){ Canvas.addEventListener('mousedown', function(e){ dragStart(e.layerX, e.layerY); }); Canvas.addEventListener('mouseup', function(e){ dragEnd(e.layerX, e.layerY); }); Canvas.addEventListener('mouseout', function(e){ dragEnd(e.layerX, e.layerY); }); Canvas.addEventListener('mousemove', function(e) { draw(e.layerX, e.layerY); }); } mouseHandler(); }); function clear(){ Context.clearRect(0, 0, Canvas.width, Canvas.height); } function sizeChange(){ ImgTag.width = WidthInputTag.value; ImgTag.height = HeightInputTag.value; Canvas.width = WidthInputTag.value; Canvas.height = HeightInputTag.value; Context.fillStyle = RectInnerColor; SpaceDivTag.style.marginTop = '' + (parseInt(HeightInputTag.value, 10) + 60) + 'px'; } function setImg(file){ clear(); index=0; DrawingMemory = {}; let reader = new FileReader(); reader.onload = function(e) { ImgTag.setAttribute('src', e.target.result); } reader.readAsDataURL(file); } function nextImg(){ Memory[fileIndex] = { \"path\": files[fileIndex].webkitRelativePath, \"label\": LabelTag.value, \"width\": WidthInputTag.value, \"height\": HeightInputTag.value, \"position\": DrawingMemory, } fileIndex+=1; if (fileIndex == filenum){ alert(\"End.\"); downloadJson(); }else{ setImg(files[fileIndex]); } } DirInputTag.addEventListener('change', function(e){ files = e.target.files; fileIndex = 0; dirname = files[fileIndex].webkitRelativePath.split(\"/\")[0]; filenum = files.length; setImg(files[fileIndex]); }); function downloadJson(){ var jsonString = JSON.stringify(Memory, null , \"\\t\"); var blob = new Blob([jsonString], { type: 'application/json' }); let link = document.createElement(\"a\"); link.href = window.URL.createObjectURL(blob); link.download = dirname + \"_AnnotatedData.json\"; link.click(); } なお、コードは ここ で簡単に解説しています。","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-16.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-16.html"},{"title":"css.2 ::befere & ::after","text":"::before や ::after は 擬似要素(Pseudo-elements) と呼ばれるもので、HTMLに直接書くことなく、選択された要素の 後 ・ 前 にスタイル付けすることができます。 作ったもの ポイント 重要な何か。 p.ex1::before { content: \"point\"; background: #f00; color: white; margin-right: 2px; padding: 1px; font-weight: bold; } < p class = \"ex1\" > 重要な何か。 </ p > < style > p . ex1 :: before { content : \"point\" ; background : #f00 ; color : white ; margin-right : 2 px ; padding : 1 px ; font-weight : bold ; } </ style > チェック事項 チェック事項的な何か。 p.ex2::before { font-family: FontAwesome; content: \"\\f00c\"; margin-right: 3px; } < p class = \"ex2\" > チェック事項的な何か。 </ p > < style > p . ex2 :: before { font-family : FontAwesome ; content : \"\\f00c\" ; margin-right : 3 px ; } </ style > フローチャート 手順１ 手順２ 手順３ .ex3 { text-align: center; list-style: none; /*黒ぽちを消す*/ } .ex3 li::after{ content: '↓'; display: block; /*改行*/ padding: 0.3em;/*余白*/ } < ul class = \"ex3\" > < li > 手順１ </ li > < li > 手順２ </ li > < li > 手順３ </ li > </ ul > < style > . ex3 { text-align : center ; list-style : none ; /*黒ぽちを消す*/ } . ex3 li :: after { content : '↓' ; display : block ; /*改行*/ padding : 0.3 em ; /*余白*/ } </ style > ただし、これだと最後の矢印が余計になってしまいます。 そこで、 XXX:not(YYY) という、 「XXXに適用するが、YYYは除く」 意味を持つ 否定擬似クラス を用いることで、この問題に対処します。（ 擬似クラス は 擬似要素 とは違い、コロンは1つです。） なお、並んでいる要素のうち最後のものを指すには :last-child という 擬似クラス を用います。 フローチャート（改良版） 風邪ひきーの 医者行きーの 受付済ませーの 待ちーの 名前呼ばれーの トツギーノ .ex4 { text-align: center; list-style: none; } .ex4 li:not(:last-child)::after{ content: '↓'; display: block; padding: 0.3em; } < ul class = \"ex4\" > < li > 風邪ひきーの </ li > < li > 医者行きーの </ li > < li > 受付済ませーの </ li > < li > 待ちーの </ li > < li > 名前呼ばれーの </ li > < li style = \"font-family: Impact,Charcoal; font-size: 2em;\" > トツギーノ </ li > </ ul > < style > . ex4 { text-align : center ; list-style : none ; } . ex4 li : not ( : last-child ) :: after { content : '↓' ; display : block ; padding : 0.3 em ; } </ style > 吹き出し ピン芸人になったバカリズム（マセキ芸能社所属）の代表作。厳格な表情でフリップをめくり、そこに描かれた絵に適した解説を「○○ーの」と厳格な口調で発するネタ。でも、オチは必ず「トツギーノ」（「嫁ぎーの」という意） 引用： はてなキーワード .ex5 { display: table; width: 100%; } .ex5__img { display: table-cell; vertical-align: middle; width: 50%; padding-right: 10px; } /* ここから */ .ex5__img::before { content: 'トツギーノ'; text-align: center; display: block; font-family: Impact,Charcoal; } .ex5__img::after { content: '出典：https://matome.naver.jp/odai/2142518805695473601'; text-align: center; display: block; font-size: 0.5em; } /* ここまでは余計 */ .ex5__callout { border: #0082af solid 4px; position: relative; background: #fff; padding: 12px; border-radius: 13px; } .ex5__callout::before { content: \"\"; position: absolute; border-right: 23px solid #0082af; border-bottom: 20px solid transparent; border-top: 20px solid transparent; top: 30%; left: -23px; } .ex5__callout::after { content: \"\"; position: absolute; border-right: 24px solid #fff; border-bottom: 20px solid transparent; border-top: 20px solid transparent; top: 30%; left: -17px; } < div class = \"ex5\" > < div class = \"ex5__img\" >< img src = \"https://rr.img.naver.jp/mig?src=http%3A%2F%2Fblog.kitamura.jp%2F03%2F4664%2Fimages%2Fm464dc8h5363e5i3_060405totugino.gif&twidth=1200&theight=1200&qlt=80&res_format=jpg&op=r\" ></ div > < div class = \"ex5__callout\" > ピン芸人になったバカリズム（マセキ芸能社所属）の代表作。厳格な表情でフリップをめくり、そこに描かれた絵に適した解説を「○○ーの」と厳格な口調で発するネタ。でも、オチは必ず「トツギーノ」（「嫁ぎーの」という意） < br > 引用： < a href = \"http://d.hatena.ne.jp/keyword/%A5%C8%A5%C4%A5%AE%A1%BC%A5%CE\" > はてなキーワード </ a ></ div > </ div > < style > . ex5 { display : table ; width : 100 % ; } . ex5__img { display : table-cell ; vertical-align : middle ; width : 50 % ; padding-right : 10 px ; } /* ここから */ . ex5__img :: before { content : 'トツギーノ' ; text-align : center ; display : block ; font-family : Impact , Charcoal ; } . ex5__img :: after { content : '出典：https://matome.naver.jp/odai/2142518805695473601' ; text-align : center ; display : block ; font-size : 0.5 em ; } /* ここまでは余計 */ . ex5__callout { border : #0082af solid 4 px ; position : relative ; background : #fff ; padding : 12 px ; border-radius : 13 px ; } . ex5__callout :: before { content : \"\" ; position : absolute ; border-right : 23 px solid #0082af ; border-bottom : 20 px solid transparent ; border-top : 20 px solid transparent ; top : 30 % ; left : -23 px ; } . ex5__callout :: after { content : \"\" ; position : absolute ; border-right : 24 px solid #fff ; border-bottom : 20 px solid transparent ; border-top : 20 px solid transparent ; top : 30 % ; left : -17 px ; } </ style >","tags":"CSS","url":"https://iwasakishuto.github.io/Front-End/tips/css-2.html","loc":"https://iwasakishuto.github.io/Front-End/tips/css-2.html"},{"title":"html.1 テーブルについて理解する。","text":"普段 markdown で文章を書いているのですが、その場合、（おそらく） テーブル内の特定の位置だけ複数列用いてセルを作る 、といったことができません。 しかし、 html のタグを用いて <table> 要素を作れば、問題なくそのようなテーブルを作ることができたので、ここではその方法を記載します。 TL;DR <td> 要素内に rowspan=\"N\" とかけばN行1列のセル colspan=\"M\" とかけば1行M列のセル rowspan=\"N\" colspan=\"M\" とかけばN行M列のセル サンプル 1 2 3 4 5 6 7 8 < table > < tr > < td rowspan = \"3\" bgcolor = \"red\" > 1 </ td > < td > 2 </ td > < td > 3 </ td > < td > 4 </ td > </ tr > < tr > < td colspan = \"2\" bgcolor = \"blue\" > 5 </ td > < td > 6 </ td > </ tr > < tr > < td > 7 </ td > < td colspan = \"2\" bgcolor = \"green\" > 8 </ td > </ tr > </ table > 今後 Timetable のページですが、セルの幅を一定にすることは可能なのですが、文字の量が多すぎるとセルの高さが大きくなってしまい、美しくありません…。 （上の各セルに文字を入力するとサイズが変わることが確認できます。） とはいえ、両方固定して科目名が全てはいらないのも美しくありません。 そこで、 各セルごとに フォントサイズ・文字の量を JavaScript で取得し、セルのサイズを変える必要がなくなるまでフォントサイズを小さくする、といったことをしてこの問題を解決したいと考えています。（時間のある時にやります。） おまけ 自由に使ってください笑 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 .M__white { background-color: white; color: white; } .M__body { background-color: #F6BC52; color: #F6BC52; } .M__red { background-color: #CC4220; color: #CC4220; } .M__black { background-color: #867724; color: #867724; } < table width = \"240px\" height = \"320px\" > < thead > < tr > < th class = \"M__white\" > 1 </ th > < th class = \"M__white\" > 1 </ th > < th class = \"M__white\" > 1 </ th > < th class = \"M__red\" > 1 </ th > < th class = \"M__red\" > 1 </ th > < th class = \"M__red\" > 1 </ th > < th class = \"M__red\" > 1 </ th > < th class = \"M__red\" > 1 </ th > < th class = \"M__white\" > 1 </ th > < th class = \"M__white\" > 1 </ th > < th class = \"M__white\" > 1 </ th > < th class = \"M__white\" > 1 </ th > </ tr > </ thead > < tbody > < tr > < td colspan = \"2\" class = \"M__white\" > 1 </ td > < td colspan = \"9\" class = \"M__red\" > 1 </ td > < td colspan = \"1\" class = \"M__white\" > 1 </ td > </ tr > < tr > < td colspan = \"2\" class = \"M__white\" > 1 </ td > < td colspan = \"3\" class = \"M__black\" > 1 </ td > < td colspan = \"2\" class = \"M__body\" > 1 </ td > < td colspan = \"1\" class = \"M__black\" > 1 </ td > < td colspan = \"1\" class = \"M__body\" > 1 </ td > < td colspan = \"3\" class = \"M__white\" > 1 </ td > </ tr > < tr > < td colspan = \"1\" class = \"M__white\" > 1 </ td > < td colspan = \"1\" class = \"M__black\" > 1 </ td > < td colspan = \"1\" class = \"M__body\" > 1 </ td > < td colspan = \"1\" class = \"M__black\" > 1 </ td > < td colspan = \"3\" class = \"M__body\" > 1 </ td > < td colspan = \"1\" class = \"M__black\" > 1 </ td > < td colspan = \"3\" class = \"M__body\" > 1 </ td > < td colspan = \"1\" class = \"M__white\" > 1 </ td > </ tr > < tr > < td colspan = \"1\" class = \"M__white\" > 1 </ td > < td colspan = \"1\" class = \"M__black\" > 1 </ td > < td colspan = \"1\" class = \"M__body\" > 1 </ td > < td colspan = \"2\" class = \"M__black\" > 1 </ td > < td colspan = \"3\" class = \"M__body\" > 1 </ td > < td colspan = \"1\" class = \"M__black\" > 1 </ td > < td colspan = \"3\" class = \"M__body\" > 1 </ td > </ tr > < tr > < td colspan = \"1\" class = \"M__white\" > 1 </ td > < td colspan = \"2\" class = \"M__black\" > 1 </ td > < td colspan = \"4\" class = \"M__body\" > 1 </ td > < td colspan = \"4\" class = \"M__black\" > 1 </ td > < td colspan = \"1\" class = \"M__white\" > 1 </ td > </ tr > < tr > < td colspan = \"3\" class = \"M__white\" > 1 </ td > < td colspan = \"7\" class = \"M__body\" > 1 </ td > < td colspan = \"2\" class = \"M__white\" > 1 </ td > </ tr > < tr > < td colspan = \"2\" class = \"M__white\" > 1 </ td > < td colspan = \"2\" class = \"M__black\" > 1 </ td > < td colspan = \"1\" class = \"M__red\" > 1 </ td > < td colspan = \"3\" class = \"M__black\" > 1 </ td > < td colspan = \"4\" class = \"M__white\" > 1 </ td > </ tr > < tr > < td colspan = \"1\" class = \"M__white\" > 1 </ td > < td colspan = \"3\" class = \"M__black\" > 1 </ td > < td colspan = \"1\" class = \"M__red\" > 1 </ td > < td colspan = \"2\" class = \"M__black\" > 1 </ td > < td colspan = \"1\" class = \"M__red\" > 1 </ td > < td colspan = \"3\" class = \"M__black\" > 1 </ td > < td colspan = \"1\" class = \"M__white\" > 1 </ td > </ tr > < tr > < td colspan = \"4\" class = \"M__black\" > 1 </ td > < td colspan = \"4\" class = \"M__red\" > 1 </ td > < td colspan = \"4\" class = \"M__black\" > 1 </ td > </ tr > < tr > < td colspan = \"2\" class = \"M__body\" > 1 </ td > < td colspan = \"1\" class = \"M__black\" > 1 </ td > < td colspan = \"1\" class = \"M__red\" > 1 </ td > < td colspan = \"1\" class = \"M__body\" > 1 </ td > < td colspan = \"2\" class = \"M__red\" > 1 </ td > < td colspan = \"1\" class = \"M__body\" > 1 </ td > < td colspan = \"1\" class = \"M__red\" > 1 </ td > < td colspan = \"1\" class = \"M__black\" > 1 </ td > < td colspan = \"2\" class = \"M__body\" > 1 </ td > </ tr > < tr > < td colspan = \"3\" class = \"M__body\" > 1 </ td > < td colspan = \"6\" class = \"M__red\" > 1 </ td > < td colspan = \"3\" class = \"M__body\" > 1 </ td > </ tr > < tr > < td colspan = \"2\" class = \"M__body\" > 1 </ td > < td colspan = \"8\" class = \"M__red\" > 1 </ td > < td colspan = \"2\" class = \"M__body\" > 1 </ td > </ tr > < tr > < td colspan = \"2\" class = \"M__white\" > 1 </ td > < td colspan = \"3\" class = \"M__red\" > 1 </ td > < td colspan = \"2\" class = \"M__white\" > 1 </ td > < td colspan = \"3\" class = \"M__red\" > 1 </ td > < td colspan = \"2\" class = \"M__white\" > 1 </ td > </ tr > < tr > < td colspan = \"1\" class = \"M__white\" > 1 </ td > < td colspan = \"3\" class = \"M__black\" > 1 </ td > < td colspan = \"4\" class = \"M__white\" > 1 </ td > < td colspan = \"3\" class = \"M__black\" > 1 </ td > < td colspan = \"1\" class = \"M__white\" > 1 </ td > </ tr > < tr > < td colspan = \"4\" class = \"M__black\" > 1 </ td > < td colspan = \"4\" class = \"M__white\" > 1 </ td > < td colspan = \"4\" class = \"M__black\" > 1 </ td > </ tr > </ tbody > </ table > < style > . M__white { background-color : white ; color : white ; } . M__body { background-color : #F6BC52 ; color : #F6BC52 ; } . M__red { background-color : #CC4220 ; color : #CC4220 ; } . M__black { background-color : #867724 ; color : #867724 ; } </ style >","tags":"HTML","url":"https://iwasakishuto.github.io/Front-End/tips/html-1.html","loc":"https://iwasakishuto.github.io/Front-End/tips/html-1.html"},{"title":"css.1 蛍光ペンを引く","text":"ここでは、大学の講義ノート （例） で使っている、 蛍光ペンでマークしたかのようなスタイル を記述しておきます。 赤いマーカー 赤いマーカーは、単純に重要なことをマークする時に使っています。 「色がついて」 「線が引いてあって」 「文字が太い」 の三点を組み合わせています。 . marker-pink { color : #c45a5a ; background : linear-gradient ( transparent 70 % , #ff66ff 60 % ); font-weight : bold ; } 青いマーカー 青いマーカーは、知識の補足が必要な時に用いています。特に生物系の用語はわからなくなることが多いので、 ホバーした時に一言説明が出る ようにしています。 . marker-info { color : #5C7DC4 ; background : linear-gradient ( transparent 70 % , #66FFCC 60 % ); font-weight : bold ; position : relative ; cursor : pointer ; } . marker-info : hover : before { opacity : 1 ; } . marker-info : before { content : attr ( aria - label ); opacity : 0 ; position : absolute ; top : 30 px ; right : -90 px ; font-size : 14 px ; width : 300 px ; padding : 10 px ; color : #fff ; background-color : #555 ; border-radius : 3 px ; pointer-events : none ; }","tags":"CSS","url":"https://iwasakishuto.github.io/Front-End/tips/css-1.html","loc":"https://iwasakishuto.github.io/Front-End/tips/css-1.html"},{"title":"JS.15 ポケモン自己分析を分析してみる","text":"body { background-image: url(\"https://www.pokemon.co.jp/corporate/job/pokemoncenter/assets/img/special/common/bg.png\"); background-color: rgb(246,224,105); } ポケモン自己分析 (Pokémon Self-analysis)とは、16個の質問に答えることで どのポケモンの要素を持つ人材になるか診断してくれる と言う面白いコンテンツです。（まだ遊んでない方は遊んで見てください！！ちなみに僕は イーブイ(eevee) でした。） 自分も含め、周りの人の結果を見ていても 「大体」 当たっており、どういう分析を行なっているのか気になったので、 ポケモン自己分析を分析 してみました。 htmlの中身を見る。 まずは html (https://www.pokemon.co.jp/corporate/job/pokemoncenter/special/question/)の中身を開発者ツールで覗きます。 すると、\b質問の度にページ遷移することなく、 JavaScript (https://www.pokemon.co.jp/corporate/job/pokemoncenter/assets/js/common.js) で要素の書き換えを行なっていることがわかりました。 また、質問を答えるボタンには以下の class が割り当てられており、これは問題番号に依存していませんでした。 < div class = \"answers\" > < button class = \"answer-yes\" id = \"yes\" > はい </ button > < button class = \"answer-no\" id = \"no\" > いいえ </ button > < button class = \"answer-neither-yes\" id = \"neither-yes\" > どちらかといえばはい </ button > < button class = \"answer-neither-no\" id = \"neither-no\" > どちらかといえばいいえ </ button > </ div > jsの中身を見る。 問題文 先ほど特定した JavaScript の中身を見たところ、まず問題文が見つかりました。 { A : { quest : [ \"データや すうじを みることが すき。\" , \"じぜんの じゅんびは しっかりする。\" , \"おおざっぱな ひとを みると イライラする。\" , \"ふかく かんがえることが すきだと おもう。\" ]}, B : { quest : [ \"かんがえる より さきに こうどう する。\" , \"けつろん から はなす ほうが すき。\" , \"つめたいと いわれることが よくある。\" , \"ムダな ことが きらい。\" ]}, C : { quest : [ \"じぶんは うけみ スタンスだ。\" , \"ひとの ためになる ことであれば なんでもできる。\" , \"ひとから やさしいと いわれる ことが よくある。\" , \"いつも そのばの くうきを よんで こうどうする。\" ]}, D : { quest : [ \"しょたいめんでも せっきょくてきに はなしかける。\" , \"いつのまにか はなしの ちゅうしんに なっている。\" , \"ひとから あかるいね と いわれる。\" , \"おもった ことが かおに よくでる。\" ]} } どうやら、 質問にはA~Dのグループが分けられており、それぞれ4種類の問題文がある ようです。 解答ボタンに対する処理 続いて、ボタンに対する処理を見つけました。 必要な部分だけ取り出すために少しプログラムを書き換えていますが、内容は同じです。 if (( e . currentTarget ). hasClass ( \"answer-yes\" )) s [ n [ r ]] += 3 ; else if (( e . currentTarget ). hasClass ( \"answer-neither-yes\" )) s [ n [ r ]] += 2 ; else if (( e . currentTarget ). hasClass ( \"answer-neither-no\" )) s [ n [ r ]] += 1 ; else (( e . currentTarget ). hasClass ( \"answer-no\" )) s [ n [ r ]] += 0 ; 「はい」に近いほど点数が高く「いいえ」に近いほど点数が低い ようです。 この点数を、先ほどのグループごとに足し合わせているようです。（ s[n[r]] は\b各グループの得点を意味。）つまり、 同じグループの問題は（広義）同じことを聞いている問題 であったと言うことです。 得点に対する処理 その後、得点を0~4に圧縮しています。以下の関数がこの役割を担います。 function u ( e ) { return e <= 3 ? 1 : e <= 7 ? 2 : e <= 10 ? 3 : e <= 12 ? 4 : void 0 } ここまでで、グループAの圧縮された得点(1-4),..,グループDの圧縮された得点(1-4)が求められます。 得点をポケモンと結びつける var e = f . default [ \"A\" . concat ( u ( s . A ), \"B\" ). concat ( u ( s . B ), \"C\" ). concat ( u ( s . C ), \"D\" ). concat ( u ( s . D ))]. name ; location . href = \"../result/\" . concat ( p . default [ e ], \".html\" ); ここでは、各種グループ記号（ A など）と圧縮された得点（ u(s.A) など）を連結して、文字列を作っています。（ A1B1C1D1 などができる。） これを、ポケモンに対応させます。これは非常に単純で、コード内に対応関係が書いてありました。 非常に長いので、注意してください。 js t.exports = { A1B1C1D1: { name: \"コイキング\" }, A1B1C1D2: { name: \"コイキング\" }, A1B1C1D3: { name: \"カビゴン\" }, A1B1C1D4: { name: \"ラッキー\" }, A1B1C2D1: { name: \"コイキング\" }, A1B1C2D2: { name: \"コダック\" }, A1B1C2D3: { name: \"カイリュー\" }, A1B1C2D4: { name: \"ラッキー\" }, A1B1C3D1: { name: \"コダック\" }, A1B1C3D2: { name: \"コダック\" }, A1B1C3D3: { name: \"カイリュー\" }, A1B1C3D4: { name: \"ラッキー\" }, A1B1C4D1: { name: \"ラッキー\" }, A1B1C4D2: { name: \"ラプラス\" }, A1B1C4D3: { name: \"ラプラス\" }, A1B1C4D4: { name: \"ラッキー\" }, A1B2C1D1: { name: \"コイキング\" }, A1B2C1D2: { name: \"コイキング\" }, A1B2C1D3: { name: \"カイリュー\" }, A1B2C1D4: { name: \"カイリュー\" }, A1B2C2D1: { name: \"フーディン\" }, A1B2C2D2: { name: \"コイキング\" }, A1B2C2D3: { name: \"カイリュー\" }, A1B2C2D4: { name: \"ラッキー\" }, A1B2C3D1: { name: \"ディグダ\" }, A1B2C3D2: { name: \"コダック\" }, A1B2C3D3: { name: \"ディグダ\" }, A1B2C3D4: { name: \"ラッキー\" }, A1B2C4D1: { name: \"ポリゴン\" }, A1B2C4D2: { name: \"ディグダ\" }, A1B2C4D3: { name: \"ラプラス\" }, A1B2C4D4: { name: \"ポリゴン\" }, A1B3C1D1: { name: \"カイリキー\" }, A1B3C1D2: { name: \"カイリキー\" }, A1B3C1D3: { name: \"メタモン\" }, A1B3C1D4: { name: \"カビゴン\" }, A1B3C2D1: { name: \"カイリキー\" }, A1B3C2D2: { name: \"カイリキー\" }, A1B3C2D3: { name: \"コダック\" }, A1B3C2D4: { name: \"ラッキー\" }, A1B3C3D1: { name: \"ディグダ\" }, A1B3C3D2: { name: \"ディグダ\" }, A1B3C3D3: { name: \"ディグダ\" }, A1B3C3D4: { name: \"ラッキー\" }, A1B3C4D1: { name: \"ポリゴン\" }, A1B3C4D2: { name: \"ポリゴン\" }, A1B3C4D3: { name: \"ポリゴン\" }, A1B3C4D4: { name: \"ラプラス\" }, A1B4C1D1: { name: \"スピアー\" }, A1B4C1D2: { name: \"カイリキー\" }, A1B4C1D3: { name: \"カイリキー\" }, A1B4C1D4: { name: \"イーブイ\" }, A1B4C2D1: { name: \"スピアー\" }, A1B4C2D2: { name: \"スピアー\" }, A1B4C2D3: { name: \"スピアー\" }, A1B4C2D4: { name: \"コダック\" }, A1B4C3D1: { name: \"スピアー\" }, A1B4C3D2: { name: \"スピアー\" }, A1B4C3D3: { name: \"スピアー\" }, A1B4C3D4: { name: \"ディグダ\" }, A1B4C4D1: { name: \"スピアー\" }, A1B4C4D2: { name: \"ポリゴン\" }, A1B4C4D3: { name: \"ラプラス\" }, A1B4C4D4: { name: \"ラプラス\" }, A2B1C1D1: { name: \"コイキング\" }, A2B1C1D2: { name: \"ニャース\" }, A2B1C1D3: { name: \"カビゴン\" }, A2B1C1D4: { name: \"ピッピ\" }, A2B1C2D1: { name: \"コイキング\" }, A2B1C2D2: { name: \"コイキング\" }, A2B1C2D3: { name: \"カイリュー\" }, A2B1C2D4: { name: \"カビゴン\" }, A2B1C3D1: { name: \"ディグダ\" }, A2B1C3D2: { name: \"コダック\" }, A2B1C3D3: { name: \"カイリュー\" }, A2B1C3D4: { name: \"ラッキー\" }, A2B1C4D1: { name: \"ポリゴン\" }, A2B1C4D2: { name: \"ラプラス\" }, A2B1C4D3: { name: \"ラプラス\" }, A2B1C4D4: { name: \"ラッキー\" }, A2B2C1D1: { name: \"マルマイン\" }, A2B2C1D2: { name: \"コイキング\" }, A2B2C1D3: { name: \"カビゴン\" }, A2B2C1D4: { name: \"ピッピ\" }, A2B2C2D1: { name: \"コイキング\" }, A2B2C2D2: { name: \"メタモン\" }, A2B2C2D3: { name: \"カイリュー\" }, A2B2C2D4: { name: \"ピッピ\" }, A2B2C3D1: { name: \"ディグダ\" }, A2B2C3D2: { name: \"ディグダ\" }, A2B2C3D3: { name: \"コダック\" }, A2B2C3D4: { name: \"ラッキー\" }, A2B2C4D1: { name: \"ポリゴン\" }, A2B2C4D2: { name: \"ラプラス\" }, A2B2C4D3: { name: \"ラプラス\" }, A2B2C4D4: { name: \"カビゴン\" }, A2B3C1D1: { name: \"フーディン\" }, A2B3C1D2: { name: \"カイリキー\" }, A2B3C1D3: { name: \"マルマイン\" }, A2B3C1D4: { name: \"ピッピ\" }, A2B3C2D1: { name: \"フーディン\" }, A2B3C2D2: { name: \"カイリキー\" }, A2B3C2D3: { name: \"メタモン\" }, A2B3C2D4: { name: \"カビゴン\" }, A2B3C3D1: { name: \"カイリキー\" }, A2B3C3D2: { name: \"フーディン\" }, A2B3C3D3: { name: \"ディグダ\" }, A2B3C3D4: { name: \"ラッキー\" }, A2B3C4D1: { name: \"ポリゴン\" }, A2B3C4D2: { name: \"ポリゴン\" }, A2B3C4D3: { name: \"コダック\" }, A2B3C4D4: { name: \"ラプラス\" }, A2B4C1D1: { name: \"リザードン\" }, A2B4C1D2: { name: \"リザードン\" }, A2B4C1D3: { name: \"リザードン\" }, A2B4C1D4: { name: \"マルマイン\" }, A2B4C2D1: { name: \"フーディン\" }, A2B4C2D2: { name: \"リザードン\" }, A2B4C2D3: { name: \"フーディン\" }, A2B4C2D4: { name: \"イーブイ\" }, A2B4C3D1: { name: \"スピアー\" }, A2B4C3D2: { name: \"スピアー\" }, A2B4C3D3: { name: \"スピアー\" }, A2B4C3D4: { name: \"コダック\" }, A2B4C4D1: { name: \"スピアー\" }, A2B4C4D2: { name: \"ポリゴン\" }, A2B4C4D3: { name: \"ポリゴン\" }, A2B4C4D4: { name: \"ポリゴン\" }, A3B1C1D1: { name: \"マルマイン\" }, A3B1C1D2: { name: \"ニャース\" }, A3B1C1D3: { name: \"ニャース\" }, A3B1C1D4: { name: \"ピッピ\" }, A3B1C2D1: { name: \"ニャース\" }, A3B1C2D2: { name: \"ニャース\" }, A3B1C2D3: { name: \"カイリュー\" }, A3B1C2D4: { name: \"ピッピ\" }, A3B1C3D1: { name: \"メタモン\" }, A3B1C3D2: { name: \"カイリュー\" }, A3B1C3D3: { name: \"カビゴン\" }, A3B1C3D4: { name: \"カイリュー\" }, A3B1C4D1: { name: \"ディグダ\" }, A3B1C4D2: { name: \"ラプラス\" }, A3B1C4D3: { name: \"ラプラス\" }, A3B1C4D4: { name: \"ラッキー\" }, A3B2C1D1: { name: \"マルマイン\" }, A3B2C1D2: { name: \"ニャース\" }, A3B2C1D3: { name: \"ニャース\" }, A3B2C1D4: { name: \"ピッピ\" }, A3B2C2D1: { name: \"ニャース\" }, A3B2C2D2: { name: \"マルマイン\" }, A3B2C2D3: { name: \"ニャース\" }, A3B2C2D4: { name: \"ピッピ\" }, A3B2C3D1: { name: \"カイリキー\" }, A3B2C3D2: { name: \"メタモン\" }, A3B2C3D3: { name: \"カイリュー\" }, A3B2C3D4: { name: \"カイリュー\" }, A3B2C4D1: { name: \"ディグダ\" }, A3B2C4D2: { name: \"コダック\" }, A3B2C4D3: { name: \"ラプラス\" }, A3B2C4D4: { name: \"カビゴン\" }, A3B3C1D1: { name: \"マルマイン\" }, A3B3C1D2: { name: \"ニャース\" }, A3B3C1D3: { name: \"フーディン\" }, A3B3C1D4: { name: \"ピッピ\" }, A3B3C2D1: { name: \"フーディン\" }, A3B3C2D2: { name: \"マルマイン\" }, A3B3C2D3: { name: \"マルマイン\" }, A3B3C2D4: { name: \"ピッピ\" }, A3B3C3D1: { name: \"カイリキー\" }, A3B3C3D2: { name: \"フーディン\" }, A3B3C3D3: { name: \"イーブイ\" }, A3B3C3D4: { name: \"カビゴン\" }, A3B3C4D1: { name: \"ポリゴン\" }, A3B3C4D2: { name: \"ポリゴン\" }, A3B3C4D3: { name: \"コダック\" }, A3B3C4D4: { name: \"コダック\" }, A3B4C1D1: { name: \"リザードン\" }, A3B4C1D2: { name: \"リザードン\" }, A3B4C1D3: { name: \"リザードン\" }, A3B4C1D4: { name: \"ニャース\" }, A3B4C2D1: { name: \"リザードン\" }, A3B4C2D2: { name: \"リザードン\" }, A3B4C2D3: { name: \"リザードン\" }, A3B4C2D4: { name: \"ニャース\" }, A3B4C3D1: { name: \"スピアー\" }, A3B4C3D2: { name: \"フーディン\" }, A3B4C3D3: { name: \"カイリキー\" }, A3B4C3D4: { name: \"イーブイ\" }, A3B4C4D1: { name: \"スピアー\" }, A3B4C4D2: { name: \"スピアー\" }, A3B4C4D3: { name: \"フーディン\" }, A3B4C4D4: { name: \"ミュウ\" }, A4B1C1D1: { name: \"ナッシー（アローラのすがた）\" }, A4B1C1D2: { name: \"ピカチュウ\" }, A4B1C1D3: { name: \"ピカチュウ\" }, A4B1C1D4: { name: \"ピッピ\" }, A4B1C2D1: { name: \"マルマイン\" }, A4B1C2D2: { name: \"ピカチュウ\" }, A4B1C2D3: { name: \"ピカチュウ\" }, A4B1C2D4: { name: \"コダック\" }, A4B1C3D1: { name: \"マルマイン\" }, A4B1C3D2: { name: \"ピカチュウ\" }, A4B1C3D3: { name: \"ピカチュウ\" }, A4B1C3D4: { name: \"ピッピ\" }, A4B1C4D1: { name: \"マルマイン\" }, A4B1C4D2: { name: \"カイリュー\" }, A4B1C4D3: { name: \"カビゴン\" }, A4B1C4D4: { name: \"ラッキー\" }, A4B2C1D1: { name: \"ナッシー（アローラのすがた）\" }, A4B2C1D2: { name: \"ニャース\" }, A4B2C1D3: { name: \"ピカチュウ\" }, A4B2C1D4: { name: \"ナッシー（アローラのすがた）\" }, A4B2C2D1: { name: \"ナッシー（アローラのすがた）\" }, A4B2C2D2: { name: \"ピカチュウ\" }, A4B2C2D3: { name: \"ピカチュウ\" }, A4B2C2D4: { name: \"カビゴン\" }, A4B2C3D1: { name: \"ナッシー（アローラのすがた）\" }, A4B2C3D2: { name: \"マルマイン\" }, A4B2C3D3: { name: \"ピカチュウ\" }, A4B2C3D4: { name: \"ピッピ\" }, A4B2C4D1: { name: \"カイリキー\" }, A4B2C4D2: { name: \"メタモン\" }, A4B2C4D3: { name: \"カビゴン\" }, A4B2C4D4: { name: \"カイリュー\" }, A4B3C1D1: { name: \"ナッシー（アローラのすがた）\" }, A4B3C1D2: { name: \"ナッシー（アローラのすがた）\" }, A4B3C1D3: { name: \"ナッシー（アローラのすがた）\" }, A4B3C1D4: { name: \"ピカチュウ\" }, A4B3C2D1: { name: \"ナッシー（アローラのすがた）\" }, A4B3C2D2: { name: \"ナッシー（アローラのすがた）\" }, A4B3C2D3: { name: \"ナッシー（アローラのすがた）\" }, A4B3C2D4: { name: \"カイリキー\" }, A4B3C3D1: { name: \"ナッシー（アローラのすがた）\" }, A4B3C3D2: { name: \"ナッシー（アローラのすがた）\" }, A4B3C3D3: { name: \"ピカチュウ\" }, A4B3C3D4: { name: \"ニャース\" }, A4B3C4D1: { name: \"フーディン\" }, A4B3C4D2: { name: \"カイリキー\" }, A4B3C4D3: { name: \"マルマイン\" }, A4B3C4D4: { name: \"ミュウ\" }, A4B4C1D1: { name: \"ラッキー\" }, A4B4C1D2: { name: \"ピカチュウ\" }, A4B4C1D3: { name: \"ピカチュウ\" }, A4B4C1D4: { name: \"ナッシー（アローラのすがた）\" }, A4B4C2D1: { name: \"リザードン\" }, A4B4C2D2: { name: \"コダック\" }, A4B4C2D3: { name: \"リザードン\" }, A4B4C2D4: { name: \"ナッシー（アローラのすがた）\" }, A4B4C3D1: { name: \"リザードン\" }, A4B4C3D2: { name: \"リザードン\" }, A4B4C3D3: { name: \"マルマイン\" }, A4B4C3D4: { name: \"ミュウ\" }, A4B4C4D1: { name: \"リザードン\" }, A4B4C4D2: { name: \"フーディン\" }, A4B4C4D3: { name: \"ミュウ\" }, A4B4C4D4: { name: \"ミュウ\" } } }, {}], ここまででポケモンの名前に変換できました。続いて、以下で英語に変換します。 この処理は不要と言えば不要ですが、日本語より英語（アルファベット）の方が何かと便利です。 ※ちなみに、ここを見れば全部で20種類のポケモンがいたこともわかります。 t . exports = { \"ピカチュウ\" : \"pikachu\" , \"ニャース\" : \"meowth\" , \"イーブイ\" : \"eevee\" , \"ナッシー（アローラのすがた）\" : \"exeggutor\" , \"リザードン\" : \"charizard\" , \"カイリキー\" : \"machamp\" , \"フーディン\" : \"alakazam\" , \"スピアー\" : \"beedrill\" , \"ポリゴン\" : \"porygon\" , \"ディグダ\" : \"diglett\" , \"コダック\" : \"psyduck\" , \"ラプラス\" : \"lapras\" , \"カイリュー\" : \"dragonite\" , \"ラッキー\" : \"chansey\" , \"カビゴン\" : \"snorlax\" , \"ピッピ\" : \"clefairy\" , \"マルマイン\" : \"electrode\" , \"ミュウ\" : \"mew\" , \"メタモン\" : \"ditto\" , \"コイキング\" : \"magikarp\" } 以上で、得点をポケモン名に変換することができました。 urlでアクセス 先ほど ../result/\".concat(p.default[e], \".html\" と言う形でurlを作っていました。そのため、 https://www.pokemon.co.jp/corporate/job/pokemoncenter/special/result/{ポケモンの英語名}.html と言う形でアクセスすれば、それぞれのポケモンの性格診断を見ることができます。 おまけ 結果の画像ファイル名が https://www.pokemon.co.jp/corporate/job/pokemoncenter/assets/img/special/share/{ポケモンの英語名}.jpg であることを利用すれば、直接各ポケモンの結果画像を入手することも可能です。 試しに、以下のテキストポックスにポケモンの英語名を入れて見てください！！ Pokémon Name window.addEventListener('DOMContentLoaded', function() { if (HTMLVideoElement) { // ページ上の要素を取得 var share = document.querySelector('#share'); var name = document.querySelector('#name'); // フォーム内の要素に変更があると発火 name.addEventListener('change', function (e) { const base = \"https://www.pokemon.co.jp/corporate/job/pokemoncenter/assets/img/special/share/\"; const extension = \".jpg\"; var url = base + name.value + extension; share.setAttribute('src', url); }); } } ) .pokemon-img{ text-align: center; margin: 20px auto; } .pokemon-name{ font-size: 1.2em; font-weight: bold; display: table-cell; padding: 8px; } label { color: #80273F; } #name { border: 0; border-bottom: 1px solid #d1d1d1; font-size: 1.2em; padding: 8px; } 再掲(\bポケモンの名前) t . exports = { \"ピカチュウ\" : \"pikachu\" , \"ニャース\" : \"meowth\" , \"イーブイ\" : \"eevee\" , \"ナッシー（アローラのすがた）\" : \"exeggutor\" , \"リザードン\" : \"charizard\" , \"カイリキー\" : \"machamp\" , \"フーディン\" : \"alakazam\" , \"スピアー\" : \"beedrill\" , \"ポリゴン\" : \"porygon\" , \"ディグダ\" : \"diglett\" , \"コダック\" : \"psyduck\" , \"ラプラス\" : \"lapras\" , \"カイリュー\" : \"dragonite\" , \"ラッキー\" : \"chansey\" , \"カビゴン\" : \"snorlax\" , \"ピッピ\" : \"clefairy\" , \"マルマイン\" : \"electrode\" , \"ミュウ\" : \"mew\" , \"メタモン\" : \"ditto\" , \"コイキング\" : \"magikarp\" } ちなみに… 以下のようにすることで、 ポケモン自己分析 (Pokémon Self-analysis)のサイトを真似ていました。 body { background-image : url ( \"https://www.pokemon.co.jp/corporate/job/pokemoncenter/assets/img/special/common/bg.png\" ); background-color : rgb ( 246 , 224 , 105 ); }","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-15.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-15.html"},{"title":"JS.14 Slack用の文字スタンプを作る","text":"\b Google Chrome の開発者ツールを使うことで、各サイトのネットワーク通信の中身（どのようなパラメータでリクエストを投げ、どのようなリスポンスが返ってきているのか）を調べることができます。 その内容を調べることで業務を効率化したり、スクレイピングを行なったりするのですが、今回はこの知識を応用して、 静的サイトにも関わらずSlackのスタンプを作る という機能を実現したいと思います。 作ったもの Special thanks go to \" 絵文字ジェネレーター - Slack 向け絵文字を無料で簡単生成 \b\" text font Noto Sans Mono CJK JP Bold M+ 1p black Rounded M+ 1p black IPAmj明朝 青柳隷書しも LinLibertine Bold text color: background color: window.addEventListener('DOMContentLoaded', function() { if (HTMLVideoElement) { // ページ上の要素を取得 var emoji = document.querySelector('#emoji'); var text = document.querySelector('#text'); var font = document.querySelector('#font'); var color = document.querySelector('#color'); var bgcolor = document.querySelector('#bgcolor'); // フォーム内の要素に変更があると発火 text.addEventListener('change', function (e) { changeSRC(emoji, text, font, color, bgcolor); }); font.addEventListener('change', function (e) { changeSRC(emoji, text, font, color, bgcolor); }); color.addEventListener('change', function (e) { changeSRC(emoji, text, font, color, bgcolor); }); bgcolor.addEventListener('change', function (e) { changeSRC(emoji, text, font, color, bgcolor); }); } } ); var changeSRC = function(emoji, text, font, color, bgcolor){ const base = \"https://emoji-gen.ninja/emoji_download?align=center&size_fixed=false&stretch=true&public_fg=true&locale=ja\"; var url = base + \"&text=\" + text.value + \"&font=\" + font.value + \"&color=\" + color.value.substring(1,7) + \"FF\" + \"&back_color=\" + bgcolor.value.substring(1,7) + \"FF\"; emoji.setAttribute('src', url) //download.setAttribute('href', url) } .display{ text-align: center; margin: 20px auto; } .container{ text-align: center; width: 100%; } .col{ font-size: 1.2em; font-weight: bold; display: table-cell; width: 33%; padding: 8px; } .col-color{ text-align: left; font-size: 1.2em; font-weight: bold; display: table-cell; width: 33%; padding: 8px; } label { color: #80273F; } #text { border: 0; border-bottom: 1px solid #d1d1d1; font-size: 1.2em; padding: 8px; } コード html < div class = \"display\" > < img id = \"emoji\" src = \"https://dashboard.snapcraft.io/site_media/appmedia/2019/01/Snapcraft_256x256.png\" width = \"128\" height = \"128\" onerror = \"this.src='https://dashboard.snapcraft.io/site_media/appmedia/2019/01/Snapcraft_256x256.png';\" /> </ div > < div class = \"container\" > < div class = \"col\" > < label for = \"text\" > text </ label >< br > < input id = \"text\" type = \"text\" placeholder = \"例）熱盛\" > </ div > < div class = \"col\" > < label for = \"font\" > font </ label >< br > < select id = \"font\" size = \"6\" > < option selected value = \"notosans-mono-bold\" > Noto Sans Mono CJK JP Bold </ option > < option value = \"mplus-1p-black\" > M+ 1p black </ option > < option value = \"rounded-x-mplus-1p-black\" > Rounded M+ 1p black </ option > < option value = \"ipamjm\" > IPAmj明朝 </ option > < option value = \"aoyagireisyoshimo\" > 青柳隷書しも </ option > < option value = \"LinLibertine_RBah\" > LinLibertine Bold </ option > </ select > </ div > < div class = \"col-color\" > < label for = \"color\" > text color: </ label >< input type = \"color\" id = \"color\" value = \"#EC71A1\" >< br > < label for = \"bgcolor\" > background color: </ label >< input type = \"color\" id = \"bgcolor\" value = \"#FFFFFF\" > </ div > </ div > JavaScript window . addEventListener ( 'DOMContentLoaded' , function () { if ( HTMLVideoElement ) { // ページ上の要素を取得 var emoji = document . querySelector ( '#emoji' ); var text = document . querySelector ( '#text' ); var font = document . querySelector ( '#font' ); var color = document . querySelector ( '#color' ); var bgcolor = document . querySelector ( '#bgcolor' ); // フォーム内の要素に変更があると発火 text . addEventListener ( 'change' , function ( e ) { changeSRC ( emoji , text , font , color , bgcolor ); }); font . addEventListener ( 'change' , function ( e ) { changeSRC ( emoji , text , font , color , bgcolor ); }); color . addEventListener ( 'change' , function ( e ) { changeSRC ( emoji , text , font , color , bgcolor ); }); bgcolor . addEventListener ( 'change' , function ( e ) { changeSRC ( emoji , text , font , color , bgcolor ); }); } } ); var changeSRC = function ( emoji , text , font , color , bgcolor ){ const base = \"https://emoji-gen.ninja/emoji_download?align=center&size_fixed=false&stretch=true&public_fg=true&locale=ja\" ; var url = base + \"&text=\" + text . value + \"&font=\" + font . value + \"&color=\" + color . value . substring ( 1 , 7 ) + \"FF\" + \"&back_color=\" + bgcolor . value . substring ( 1 , 7 ) + \"FF\" ; emoji . setAttribute ( 'src' , url ) //download.setAttribute('href', url) } css . display { text-align : center ; margin : 20 px auto ; } . container { text-align : center ; width : 100 % ; } . col { font-size : 1.2 em ; font-weight : bold ; display : table-cell ; width : 33 % ; padding : 8 px ; } . col-color { text-align : left ; font-size : 1.2 em ; font-weight : bold ; display : table-cell ; width : 33 % ; padding : 8 px ; } label { color : #80273F ; } # text { border : 0 ; border-bottom : 1 px solid #d1d1d1 ; font-size : 1.2 em ; padding : 8 px ; }","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-14.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-14.html"},{"title":"JS.13 GASでslackにメッセージを送る","text":"GASとは Google Apps Script(GAS, ガス) とは、Googleが提供するサーバーサイド・スクリプト環境です。 JavaScript じゃないやんって感じかもしれませんが、 JavaScript っぽいなと思ったのでかなり前から使っていたのですが一度まとめることにしました。 シェアハウスのslackで必要だと感じた 「予定を共有すること」 と 「家事の役割分担をすること」 を自動化しました。 その日の予定を共有する関数 以下のようなものができます。 listupEvent gmailアドレスを受け取り、その日にある予定を全て取得する関数 function listupEvent ( cal_id ){ var list = \"\" ; var cal = CalendarApp . getCalendarById ( cal_id ); var events = cal . getEventsForDay ( new Date ()); for ( var i = 0 ; i < events . length ; i ++ ){ s = \"\" ; if ( events [ i ]. isAllDayEvent ()) { s += Utilities . formatDate ( events [ i ]. getStartTime (), \"GMT+0900\" , \"MM/dd \" ); } else { s += Utilities . formatDate ( events [ i ]. getStartTime (), \"GMT+0900\" , \"MM/dd HH:mm\" ); s += Utilities . formatDate ( events [ i ]. getEndTime (), \"GMT+0900\" , \"-HH:mm \" ); } s += events [ i ]. getTitle (); list += s + \"\\n\" ; } return list ; } CalcuDaySpan 特定の日からの経過時間、特定の日までの残り時間を計算する関数。エモい。 function CalcuDaySpan (){ var start = Moment . moment ( 'YYYY/MM/DD' ); // 開始日（ −１日 ） var end = Moment . moment ( 'YYYY/MM/DD' ). add ( 'years' , 2 ); var now = Moment . moment (); var message = 'おはよう！〇〇から今日で *' + now . diff ( start , 'days' ) + '日* だね。××まであと *' + - now . diff ( end , 'days' ) + '日* 、今日も濃い一日を！！\\n' ; return message ; } postSlack JSON形式で payload にslackに送信する際の情報を渡せば、slackにうまく送信されます。 // slackに送信する function postSlack ( payload ){ var options = { \"method\" : \"POST\" , 'contentType' : 'application/json' , 'payload' : JSON . stringify ( payload ) }; var url = \"https://hooks.slack.com/services/XXX/YYY/ZZZ\" ; // Webhook URL var response = UrlFetchApp . fetch ( url , options ); var content = response . getContentText ( \"UTF-8\" ); } shareCalendar 上記の関数を駆使してslackにメッセージを送る関数。みんな大好き橋本環奈のアイコンで送信することで、朝の気分を少しでも良くします。 function shareCalendar () { var list = \"\" ; var s ; var Members = [ \"<@UAAAAAAAA>\" , \"<@UBBBBBBBB>\" , \"<@UCCCCCCCC>\" , \"<@UDDDDDDDD>\" ]; var Address = [ \"AAA@gmail.com\" , \"BBB@gmail.com\" , \"CCC@gmail.com\" , \"DDD@gmail.com\" ]; for ( var i = 0 ; i < Members . length ; i ++ ){ s = listupEvent ( Address [ i ]); if ( s != \"\" ) list += \"\\n■今日の\" + Members [ i ] + \"の予定\\n\" + s ; } if ( list != \"\" ) { var title = CalcuDaySpan (); var payload = { \"channel\" : \"#channel name\" , \"username\" : \"bot name\" , \"text\" : title + list , } postSlack ( payload ); } } 朝、その日の夜に洗濯物を取り込む人を決める関数 以下のようなものができます。 getWeatherData 気象庁 | 天気予報：東京都 のサイトをスクレイピングして、欲しい情報を取得します。 // 天気を取得する function getWeatherData () { // データ取得 var url = \"http://www.jma.go.jp/jp/yoho/319.html\" ; // 東京の天気 var response = UrlFetchApp . fetch ( url ); // URL から html var data = response . getContentText (); // 大雑把に分割＆配列化 var ary = data . split ( \"<th class=\\\"weather\\\">\" )[ 2 ]; // 朝6時から24時までの降水確率 var ary_pop = ary . split ( \"%\" ); // Probability Of Precipitation ary_pop . pop (); var ary_rainy = []; for ( var i in ary_pop ) { var pop = ary_pop [ i ]. substr ( - 2 ); if ( pop == \">0\" ) pop = \"0\" ; ary_rainy . push ( pop + \"%\" ); } var str_pop = \"00-06：\" + ary_rainy [ 0 ] + \"\\n06-12：\" + ary_rainy [ 1 ] + \"\\n12-18：\" + ary_rainy [ 2 ] + \"\\n18-24：\" + ary_rainy [ 3 ]; // 最低最高気温 var min = ary . split ( \"min\" )[ 1 ]. match ( />(.+?)</g )[ 0 ]. slice ( 1 , - 1 ); // 記録がない場合は「---」に置き換える if ( min == \"</t\" ) min = \"---\" ; var max = ary . split ( \"max\" )[ 1 ]. match ( />(.+?)</g )[ 0 ]. slice ( 1 , - 1 ); if ( max == \"</t\" ) max = \"---\" ; var str_temp = \"朝の最低気温 ：\" + min + \"\\n日中の最高気温：\" + max ; // 天気を言葉で取得 var weather = ary . match ( /title=\"(.+?)\"/g )[ 0 ]. slice ( 7 , - 1 ); // 天気の画像取得 var img = ary . match ( /src=\"(.*?)\"/g )[ 0 ]. slice ( 5 , - 1 ); var img_url = \"http://www.jma.go.jp/jp/yoho/\" + img ; var weather_str = \"*\" + weather + \"*\\n\" + img_url + \"\\n`【降水確率】`\\n\" + str_pop + \"\\n`【気温】`\\n\" + str_temp + \"\\n\" ; return weather_str ; 具体的には、以下の内容を返します。 * 曇り時々晴れ * http : // www . jma . go . jp / jp / yoho / img / 201. png `【 降水確率 】` 00 - 06 ： 0 % 06 - 12 ： 10 % 12 - 18 ： 30 % 18 - 24 ： 30 % `【 気温 】` 朝の最低気温 ： 19 度 日中の最高気温 ： 28 度 getDayOfWeek date.getDay() がインデックスで曜日を返すので、それを単純に日本語に直すだけの関数です。 // 曜日を取得する function getDayOfWeek ( date ) { var dayOfWeek = date . getDay (); var dayOfWeekStr = [ \"日\" , \"月\" , \"火\" , \"水\" , \"木\" , \"金\" , \"土\" ][ dayOfWeek ]; return dayOfWeekStr } getDayOfToday 今日の日付と曜日を取得する関数です。 function getDayOfTomorrow (){ // 明日の日付取得 var date = new Date (); var today = Utilities . formatDate ( date , 'Asia/Tokyo' , 'MM月dd日' ); var youbi = getDayOfWeek ( date ); var str_date = today + \"(\" + youbi + \")\" ; return str_date ; // 06月19日(水) など。 } assignRole 洗濯物を取り込む人を決める 重要な 関数です。 function assignRole (){ // 洗濯物を取り込む人を決定 // 各メンバーのID var Members = [ \"<@UAAAAAAAA>\" , \"<@UBBBBBBBB>\" , \"<@UCCCCCCCC>\" , \"<@UDDDDDDDD>\" ]; var num = Members . length ; // 人数 var index = Math . floor ( Math . random () * num ); // ランダムで 0~num-1 を生成 var role = Members [ index ]; var str_date = getDayOfToday (); var weather_str = getWeatherData (); var payload = { \"text\" : \"今日は\" + role + \"お願いね！\\n今日 \" + str_date + \" の天気： \" + weather_str , \"channel\" : \"#laundry\" , \"username\" : \"みくりさん\" , \"icon_url\" : \"https://pbs.twimg.com/profile_images/804164014473289728/OCNtA0UO_400x400.jpg\" , // アイコン画像 } postSlack ( payload ); } 明日の朝洗濯物を干す人を決める関数 基本的には上と同じです笑 大きな変更点といえば、今回はランダムで 2人アサインしている ということです。朝洗濯物を干すのは大変ですからね。 あと、平匡さんにしてます。わかりづらくなってしまうので。 function assignRole (){ // 洗濯物を干す人を決定 var Members = [ \"<@UAAAAAAAA>\" , \"<@UBBBBBBBB>\" , \"<@UCCCCCCCC>\" , \"<@UDDDDDDDD>\" ]; var num = Members . length ; // 人数 var index = Math . floor ( Math . random () * num ); var index2 = Math . floor ( Math . random () * num ); while ( index === index2 ){ index2 = Math . floor ( Math . random () * num ); Logger . log ( index2 ); } var role = Members [ index ]; var role2 = Members [ index2 ]; var str_date = getDayOfTomorrow (); var weather_str = getWeatherData (); var payload = { \"text\" : \"明日の朝は\" + role + \"と\" + role2 + \"お願いね！\\n明日 \" + str_date + \" の天気： \" + weather_str , \"channel\" : \"#laundry\" , \"username\" : \"平匡さん\" , \"icon_url\" : \"https://i.pinimg.com/originals/4a/47/b7/4a47b71d373217dc578f05a7b9ff5ce0.jpg\" , // アイコン画像 } postSlack ( payload ); }","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-13.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-13.html"},{"title":"JS.12 Node.jsでコマンドメモアプリケーション","text":"講座： Node.js速習講座 Part1 <導入＆基礎編> 講師： Yu Hiraga Node.jsとは Node.js (略してNode)は、 ブラウザ側で機能する言語であったJavaScriptをサーバー側で動作するようにしたもの。 使い方 以下の hello.js というファイルを node hello.js （または拡張子を無視して node hello ）というコマンドで立ち上げる事ができる。 console . log ( \"Hello, world!\" ); $ node hello.js > Hello, world! npm npm とは、 \"Node Package Manager\" の略で、Node関連の便利ツールを扱うもの。代表的なものには以下のモジュールがある。 パッケージ名 説明 express ホームページを表示させる cordova モバイルデバイスとの連携をしやすくする forever サーバーが落ちてから再起動する際、Nodeプログラムも同時にかつ自動的に再起動する。 第三者が無償で提供しているものがたくさんあるので、使えるものがあるのであれば積極的に使うべき。 作ったもの コマンドラインから操作するメモ帳アプリケーションを作成した。なお、コードは ECMAScript を採用して書いている。 メモ追加 $ node app.js add --title = memo1 --body = initial commit. 保存されました。 ------------- タイトル：memo1 内容：initial ここで、 notes-data.json \bの中身は以下のようになっている。 [{ \"title\" : \"memo1\" , \"body\" : \"initial\" }] $ node app.js add --title = memo2 --body = second commit. 保存されました。 ------------- タイトル：memo2 内容：second [{ \"title\" : \"memo1\" , \"body\" : \"initial\" },{ \"title\" : \"memo2\" , \"body\" : \"second\" }] メモ表示（全部） $ node app.js list 表示数：2 ------------- タイトル：memo1 内容：initial ------------- タイトル：memo2 内容：second メモ表示（一部） $ node app.js read --title = memo2 見つかりました。 ------------- タイトル：memo2 内容：second メモ削除 $ node app.js remove --title = memo3 削除されませんでした。 $ node app.js remove --title = memo2 削除されました。 [{ \"title\" : \"memo1\" , \"body\" : \"initial\" }] コード 以下のようなディレクトリ構造下で行う。 ├── app.js # メモアプリの入り口となるスクリプト ├── node_modules # npm install したライブラリが入っている。 │ └── ... ├── notes-data.json # メモが保存されるjsonファイル ├── notes.js # app.jsで呼び出す関数が書かれている。 ├── package-lock.json # 同じpackage.jsonからのモジュールインストールが、違ったインストールに陥る結果を回避するためのもの。 └── package.json # どのようなライブラリをインストールしたかなど app.js // メモアプリの入り口となる関数。 const fs = require ( \"fs\" ); const notes = require ( \"./notes.js\" ); const yargs = require ( \"yargs\" ); // argv よりも多機能なのでこちらを採用。 const argv = yargs . argv ; const command = argv . _ [ 0 ] if ( command === \"add\" ){ let note = notes . addNote ( argv . title , argv . body ); // 保存された内容をアウトプット if ( note ){ console . log ( \"保存されました。\" ); notes . logNotes ( note ); } else { console . log ( \"タイトルが重複しています。\" ); } } else if ( command === \"list\" ){ let allNotes = notes . showAll (); console . log ( `表示数： ${ allNotes . length } ` ); allNotes . forEach ( note => notes . logNotes ( note )); } else if ( command === \"read\" ){ let note = notes . readNote ( argv . title ); if ( note ){ console . log ( \"見つかりました。\" ); notes . logNotes ( note ); } else { console . log ( \"データが見つかりませんでした。\" ); } } else if ( command === \"remove\" ){ let noteRemoved = notes . removeNote ( argv . title ); let message = noteRemoved ? \"削除されました。\" : \"削除されませんでした。\" ; console . log ( message ); } notes.js const fs = require ( \"fs\" ) // ノートの内容を取得する。（存在しなければ空の配列） let fetchNotes = () => { try { let notesString = fs . readFileSync ( \"notes-data.json\" ); return JSON . parse ( notesString ); } catch ( e ){ return []; } }; // ノートの内容を保存する。 let saveNotes = notes => { fs . writeFileSync ( \"notes-data.json\" , JSON . stringify ( notes )); } // ノートに書き込む関数 let addNote = ( title , body ) => { let notes = fetchNotes (); let note = { title , body }; // 同じタイトルのデータがあれば何もしない。 let duplicatedNotes = notes . filter ( note => note . title === title ); if ( duplicatedNotes . length === 0 ){ notes . push ( note ); saveNotes ( notes ); return note ; } } let showAll = () => { return fetchNotes (); } let readNote = title => { let notes = fetchNotes (); let filteredNotes = notes . filter ( note => note . title === title ); return filteredNotes [ 0 ]; // 1つしか見つからないはずだからindexは0。 } // 指定したタイトルのデータを削除。 let removeNote = title => { let notes = fetchNotes (); // 指定したタイトルにマッチしないデータのみを残して保存。 let filteredNotes = notes . filter ( note => note . title !== title ); saveNotes ( filteredNotes ); // データが削除されたか（データ数が減ったか）のbool値を返す。 return notes . length !== filteredNotes . length ; } let logNotes = ( note ) => { console . log ( \"-------------\" ); console . log ( `タイトル： ${ note . title } ` ); console . log ( `内容： ${ note . body } ` ); }; module . exports = { addNote , showAll , readNote , removeNote , logNotes }; package.json { \"name\" : \"memo\" , \"version\" : \"1.0.0\" , \"description\" : \"Command line memo application\" , \"main\" : \"app.js\" , \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\" : \"shuto\" , \"license\" : \"ISC\" , \"dependencies\" : { \"express\" : \"*\" , \"grunt\" : \"&#94;1.0.4\" , \"yargs\" : \"&#94;4.7.1\" } }","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-12.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-12.html"},{"title":"JS.11 TensorFlow.jsでMNIST","text":"機械学習のチュートリアルでおなじみMNISTを TensorFlow.js でやってみました。 下のキャンバスに0~9の数字を書いて、 predict ボタンを押してみてください！！ 作ったもの reset Number Accuracy 0 - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - .mnist { padding: 10px; width: 100%; overflow: hidden; } .drawing { float: left; width: 50%; text-align: center; } .result { float: right; width: 50%; } .predict{ padding: 10px; background-color: #80160e; } .reset { padding: 10px; background-color: #c8c8a0; } .is-selected { background-color: #80160e; color: white; } @media only screen and (max-width: 1200px) { .drawing { width: 100%; text-align: center; } .result { width: 100%; } } @media only screen and (max-width: 760px) { .drawing { float: left; width: 50%; text-align: center; } .result { float: right; width: 50%; } } @media only screen and (max-width: 640px) { .drawing { width: 100%; text-align: center; } .result { width: 100%; } } // init SignaturePad const drawElement = document.getElementById('drawing-pad'); const signaturePad = new SignaturePad(drawElement, { minWidth: 6, maxWidth: 6, penColor: 'white', backgroundColor: 'black', }); // load pre-trained model let model; const model_path = '../../js/TensorFlowJs/MNIST/tf-model/model.json' tf.loadModel(model_path) .then(function(pretrainedModel){ model = pretrainedModel; document.getElementById('predict-button').innerHTML = \"predict\"; document.getElementById('loading').style.disabled=\"true\"; }); function getImageData() { // grayscale const src = cv.imread(drawElement); let dst_gray = new cv.Mat(); cv.cvtColor(src, dst_gray, cv.COLOR_RGBA2GRAY, 0); // resize let dst_resized = new cv.Mat(); let dsize = new cv.Size(28, 28); cv.resize(dst_gray, dst_resized, dsize, 0, 0, cv.INTER_AREA); cv.imshow('hidden-pad', dst_resized); const imageData = document.getElementById('hidden-pad').getContext('2d').getImageData(0, 0, 28, 28); src.delete(); dst_gray.delete(); dst_resized.delete(); return imageData; } function getAccuracyScores(imageData) { // メモリリークの心配がなくなる。自動的にメモリを解放。 const score = tf.tidy(function () { const channels = 1; let input = tf.fromPixels(imageData, channels); input = tf.cast(input, 'float32').div(tf.scalar(255)); input = input.expandDims(); return model.predict(input).dataSync(); }); return score; } function prediction() { const imageData = getImageData(); const accuracyScores = getAccuracyScores(imageData); const maxAccuracy = accuracyScores.indexOf(Math.max.apply(null, accuracyScores)); const elements = document.querySelectorAll(\".accuracy\"); elements.forEach(function (el){ el.parentNode.classList.remove('is-selected'); const rowIndex = Number(el.dataset.rowIndex); if (maxAccuracy === rowIndex) { el.parentNode.classList.add('is-selected'); } el.innerText = accuracyScores[rowIndex]; }) } function reset() { signaturePad.clear(); let elements = document.querySelectorAll(\".accuracy\"); elements.forEach(function (el){ el.parentNode.classList.remove('is-selected'); el.innerText = '-'; }) } モデルの学習 なお、訓練は Mnist cnn - Keras Documentation に従って行なっていますが、一応モデルの重みを TensorFlow.js の形式に変換するところまでを含めて notebook にまとめてあります。 また、 TensorFlow.js に関しては、 README.md に簡単にまとめてあります。 コード < div class = \"mnist\" > < div class = \"drawing\" > < canvas id = \"drawing-pad\" width = \"280\" height = \"280\" style = \"border: 2px solid;\" ></ canvas > < canvas id = \"hidden-pad\" style = \"display: none;\" ></ canvas >< br /> < button id = \"predict-button\" class = \"predict\" onclick = \"prediction()\" > < i id = \"loading\" class = \"fa fa-spinner fa-spin\" style = \"disabled: false;\" ></ i > </ button > < button id = \"reset-button\" class = \"reset\" onclick = \"reset()\" > reset </ button > </ div > < div class = \"result\" > < table > < thead > < tr > < th > Number </ th > < th > Accuracy </ th > </ tr > </ thead > < tbody > < tr > < th > 0 </ th > < td class = \"accuracy\" data-row-index = \"0\" > - </ td > </ tr > < tr > < th > 1 </ th > < td class = \"accuracy\" data-row-index = \"1\" > - </ td > </ tr > < tr > < th > 2 </ th > < td class = \"accuracy\" data-row-index = \"2\" > - </ td > </ tr > < tr > < th > 3 </ th > < td class = \"accuracy\" data-row-index = \"3\" > - </ td > </ tr > < tr > < th > 4 </ th > < td class = \"accuracy\" data-row-index = \"4\" > - </ td > </ tr > < tr > < th > 5 </ th > < td class = \"accuracy\" data-row-index = \"5\" > - </ td > </ tr > < tr > < th > 6 </ th > < td class = \"accuracy\" data-row-index = \"6\" > - </ td > </ tr > < tr > < th > 7 </ th > < td class = \"accuracy\" data-row-index = \"7\" > - </ td > </ tr > < tr > < th > 8 </ th > < td class = \"accuracy\" data-row-index = \"8\" > - </ td > </ tr > < tr > < th > 9 </ th > < td class = \"accuracy\" data-row-index = \"9\" > - </ td > </ tr > </ tbody > </ table > </ div > </ div > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/signature_pad/1.5.3/signature_pad.min.js\" ></ script > < script src = \"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.8.0\" ></ script > < script src = \"https://docs.opencv.org/3.4/opencv.js\" type = \"text/javascript\" ></ script > JavaScript // init SignaturePad const drawElement = document . getElementById ( 'drawing-pad' ); const signaturePad = new SignaturePad ( drawElement , { minWidth : 6 , maxWidth : 6 , penColor : 'white' , backgroundColor : 'black' , }); // load pre-trained model let model ; const model_path = '../../js/TensorFlowJs/MNIST/tf-model/model.json' tf . loadModel ( model_path ) . then ( function ( pretrainedModel ){ model = pretrainedModel ; document . getElementById ( 'predict-button' ). innerHTML = \"predict\" ; document . getElementById ( 'loading' ). style . disabled = \"true\" ; }); function getImageData () { // grayscale const src = cv . imread ( drawElement ); let dst_gray = new cv . Mat (); cv . cvtColor ( src , dst_gray , cv . COLOR_RGBA2GRAY , 0 ); // resize let dst_resized = new cv . Mat (); let dsize = new cv . Size ( 28 , 28 ); cv . resize ( dst_gray , dst_resized , dsize , 0 , 0 , cv . INTER_AREA ); cv . imshow ( 'hidden-pad' , dst_resized ); const imageData = document . getElementById ( 'hidden-pad' ). getContext ( '2d' ). getImageData ( 0 , 0 , 28 , 28 ); src . delete (); dst_gray . delete (); dst_resized . delete (); return imageData ; } function getAccuracyScores ( imageData ) { // メモリリークの心配がなくなる。自動的にメモリを解放。 const score = tf . tidy ( function () { const channels = 1 ; let input = tf . fromPixels ( imageData , channels ); input = tf . cast ( input , 'float32' ). div ( tf . scalar ( 255 )); input = input . expandDims (); return model . predict ( input ). dataSync (); }); return score ; } function prediction () { const imageData = getImageData (); const accuracyScores = getAccuracyScores ( imageData ); const maxAccuracy = accuracyScores . indexOf ( Math . max . apply ( null , accuracyScores )); const elements = document . querySelectorAll ( \".accuracy\" ); elements . forEach ( function ( el ){ el . parentNode . classList . remove ( 'is-selected' ); const rowIndex = Number ( el . dataset . rowIndex ); if ( maxAccuracy === rowIndex ) { el . parentNode . classList . add ( 'is-selected' ); } el . innerText = accuracyScores [ rowIndex ]; }) } function reset () { signaturePad . clear (); let elements = document . querySelectorAll ( \".accuracy\" ); elements . forEach ( function ( el ){ el . parentNode . classList . remove ( 'is-selected' ); el . innerText = '-' ; }) } css . mnist { padding : 10 px ; width : 100 % ; overflow : hidden ; } . drawing { float : left ; width : 50 % ; text-align : center ; } . result { float : right ; width : 50 % ; } . predict { padding : 10 px ; background-color : #80160e ; } . reset { padding : 10 px ; background-color : #c8c8a0 ; } . is-selected { background-color : #80160e ; color : white ; } @ media only screen and ( max-width : 1200px ) { . drawing { width : 100 % ; text-align : center ; } . result { width : 100 % ; } } @ media only screen and ( max-width : 760px ) { . drawing { float : left ; width : 50 % ; text-align : center ; } . result { float : right ; width : 50 % ; } } @ media only screen and ( max-width : 640px ) { . drawing { width : 100 % ; text-align : center ; } . result { width : 100 % ; } }","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-11.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-11.html"},{"title":"JS.10 OpenCVで遊ぶ","text":"作ったもの 画像にいくつかの処理を（一度に一つだけ）加えることのできるアプリケーションです。線画化が意外といい感じに仕上がるので、試してみてください。 Source Output 処理方法 グレースケール化 線画化 リサイズ化 横幅 px 縦幅 px const srcImg = document.getElementById('src-image'); const hiddenImg = document.getElementById('hidden-image'); const fileInput = document.getElementById('input-file'); const canvas = document.getElementById('dest-canvas'); const hiddenCanvas = document.getElementById('hidden-canvas'); const grayScaleBtn = document.getElementById('gray-scale-btn'); const lineDrawBtn = document.getElementById('linedraw-btn'); const downloadBtn = document.getElementById('download-btn'); const resizeBtn = document.getElementById('resize-btn'); const executeBtn = document.getElementById('execute-btn'); const resizeSize = document.getElementsByName('resizeSize'); // OpenCVメソッドを全て引き受ける function EventHandler(func, ...args){ const src = cv.imread(srcImg); const dst = func(src, ...args); cv.imshow('dest-canvas', dst); src.delete(); dst.delete(); const hiddenSrc = cv.imread(hiddenImg); const hiddenDst = func(hiddenSrc, ...args); cv.imshow('hidden-canvas', hiddenDst); hiddenSrc.delete(); hiddenDst.delete(); } function convertImageToGray(img) { let dst = new cv.Mat(); cv.cvtColor(img, dst, cv.COLOR_RGBA2GRAY, 0); return dst; } function convertImageToLineDrawing(img) { const kernel = cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(5,5)); const imgGray = new cv.Mat(); cv.cvtColor(img, imgGray, cv.COLOR_RGBA2GRAY); const imgDilated = new cv.Mat(); cv.dilate(imgGray, imgDilated, kernel, new cv.Point(-1, 1), 1); const imgDiff = new cv.Mat(); cv.absdiff(imgDilated, imgGray, imgDiff); const contour = new cv.Mat(); cv.bitwise_not(imgDiff, contour); return contour; } function convertImageRisze(img, width, height) { let dst = new cv.Mat(); let dsize = new cv.Size(width, height); cv.resize(img, dst, dsize, 0, 0, cv.INTER_AREA); return dst; } // Execute Button executeBtn.addEventListener('click', function(){ var radios = document.getElementsByName(\"method\"); if (radios[0].checked) EventHandler(convertImageToGray); if (radios[1].checked) EventHandler(convertImageToLineDrawing); if (radios[2].checked) EventHandler( convertImageRisze, parseInt(document.getElementById(\"resize-width\").value), parseInt(document.getElementById(\"resize-height\").value) ); }); // Input Button fileInput.addEventListener('change', function(e){ srcImg.src = URL.createObjectURL(e.target.files[0]); hiddenImg.src = URL.createObjectURL(e.target.files[0]); const src = cv.imread(hiddenImg); }, false); // Make URL for Download function dataUriToBlob(dataUri) { const b64 = atob(dataUri.split(',')[1]); const u8 = Uint8Array.from(b64.split(''), e => e.charCodeAt()); return new Blob([u8], {type: 'image/png'}); } // Download Button downloadBtn.addEventListener('click', function(e){ let data = hiddenCanvas.toDataURL(); let url = URL.createObjectURL(dataUriToBlob(data)); let link = document.createElement(\"a\"); link.href = url; link.download = \"processed.png\"; link.click(); }) function changeDisabled() { if (document.getElementsByName(\"method\")[2].checked ) { resizeSize[0].disabled = false; resizeSize[1].disabled = false; } else { resizeSize[0].disabled = true; resizeSize[1].disabled = true; } } window.onload = changeDisabled(); ul { list-style: none; } label { display: inline-flex; margin-bottom: 0; } 動機 色々と覚えてきたので、最後に OpenCV.js Webカメラ\b Canvas TensorFlow.js あたりを使って 静的サイトで機械学習のWebアプリケーションを動かし 、 JavaScript の勉強は一旦終了にしようと思いました。そこで、まずは OpenCV.js から使ってみようと思い、上記のアプリケーションを作りました。 あと、地味に毎回 Python やシェルでコード書いたり、 PowerPoint 使って画像のリサイズするのが面倒だったので意外と重宝しています笑 コード html < table > < thead > < tr > < th align = \"center\" > Source </ th > < th align = \"center\" > Output </ th > </ tr > </ thead > < tbody > < tr > < td > < img id = \"src-image\" src = \"https://iwasakishuto.github.io/images/apple-touch-icon/base.png\" /> < img id = \"hidden-image\" src = \"https://iwasakishuto.github.io/images/apple-touch-icon/base.png\" style = \"display: none;\" /> </ td > < td > < canvas id = \"dest-canvas\" ></ canvas > < canvas id = \"hidden-canvas\" style = \"display: none;\" ></ canvas > </ td > </ tr > < tr > < td align = \"center\" > <!-- 入力ファイル選択 --> < input type = \"file\" id = \"input-file\" /> </ td > < td align = \"center\" > <!-- ダウンロード --> < input id = \"download-btn\" type = \"button\" value = \"ダウンロード\" > </ td > </ tbody > </ table > <!-- 処理方法を選択 --> < form name = \"Processing Method\" action = \"#\" > < h2 > 処理方法 </ h2 > < ul > < li >< input type = \"radio\" name = \"method\" id = \"gray-scale-btn\" onClick = \"changeDisabled()\" >< label for = \"gray-scale-btn\" > グレースケール化 </ label ></ li > < li >< input type = \"radio\" name = \"method\" id = \"linedraw-btn\" onClick = \"changeDisabled()\" >< label for = \"linedraw-btn\" > 線画化 </ label ></ li > < li >< input type = \"radio\" name = \"method\" id = \"resize-btn\" onClick = \"changeDisabled()\" >< label for = \"resize-btn\" > リサイズ化 </ label > < label for = \"gray-scale-btn\" > 横幅 </ label >< p style = \"display:inline;\" >< input type = \"number\" id = \"resize-width\" name = \"resizeSize\" step = \"10\" min = \"10\" max = \"1000\" value = \"400\" > px </ p > < label for = \"gray-scale-btn\" > 縦幅 </ label >< p style = \"display:inline;\" >< input type = \"number\" id = \"resize-height\" name = \"resizeSize\" step = \"10\" min = \"10\" max = \"1000\" value = \"400\" > px </ p ></ li > </ ul > < input id = \"execute-btn\" type = \"button\" value = \"実行\" > </ form > < script src = \"https://docs.opencv.org/3.4/opencv.js\" type = \"text/javascript\" ></ script > JavaScript const srcImg = document . getElementById ( 'src-image' ); const hiddenImg = document . getElementById ( 'hidden-image' ); const fileInput = document . getElementById ( 'input-file' ); const canvas = document . getElementById ( 'dest-canvas' ); const hiddenCanvas = document . getElementById ( 'hidden-canvas' ); const grayScaleBtn = document . getElementById ( 'gray-scale-btn' ); const lineDrawBtn = document . getElementById ( 'linedraw-btn' ); const downloadBtn = document . getElementById ( 'download-btn' ); const resizeBtn = document . getElementById ( 'resize-btn' ); const executeBtn = document . getElementById ( 'execute-btn' ); const resizeSize = document . getElementsByName ( 'resizeSize' ); // OpenCVメソッドを全て引き受ける function EventHandler ( func , ... args ){ const src = cv . imread ( srcImg ); const dst = func ( src , ... args ); cv . imshow ( 'dest-canvas' , dst ); src . delete (); dst . delete (); const hiddenSrc = cv . imread ( hiddenImg ); const hiddenDst = func ( hiddenSrc , ... args ); cv . imshow ( 'hidden-canvas' , hiddenDst ); hiddenSrc . delete (); hiddenDst . delete (); } function convertImageToGray ( img ) { let dst = new cv . Mat (); cv . cvtColor ( img , dst , cv . COLOR_RGBA2GRAY , 0 ); return dst ; } function convertImageToLineDrawing ( img ) { const kernel = cv . getStructuringElement ( cv . MORPH_RECT , new cv . Size ( 5 , 5 )); const imgGray = new cv . Mat (); cv . cvtColor ( img , imgGray , cv . COLOR_RGBA2GRAY ); const imgDilated = new cv . Mat (); cv . dilate ( imgGray , imgDilated , kernel , new cv . Point ( - 1 , 1 ), 1 ); const imgDiff = new cv . Mat (); cv . absdiff ( imgDilated , imgGray , imgDiff ); const contour = new cv . Mat (); cv . bitwise_not ( imgDiff , contour ); return contour ; } function convertImageRisze ( img , width , height ) { let dst = new cv . Mat (); let dsize = new cv . Size ( width , height ); cv . resize ( img , dst , dsize , 0 , 0 , cv . INTER_AREA ); return dst ; } // Execute Button executeBtn . addEventListener ( 'click' , function (){ var radios = document . getElementsByName ( \"method\" ); if ( radios [ 0 ]. checked ) EventHandler ( convertImageToGray ); if ( radios [ 1 ]. checked ) EventHandler ( convertImageToLineDrawing ); if ( radios [ 2 ]. checked ) EventHandler ( convertImageRisze , parseInt ( document . getElementById ( \"resize-width\" ). value ), parseInt ( document . getElementById ( \"resize-height\" ). value ) ); }); // Input Button fileInput . addEventListener ( 'change' , function ( e ){ srcImg . src = URL . createObjectURL ( e . target . files [ 0 ]); hiddenImg . src = URL . createObjectURL ( e . target . files [ 0 ]); const src = cv . imread ( hiddenImg ); }, false ); // Make URL for Download function dataUriToBlob ( dataUri ) { const b64 = atob ( dataUri . split ( ',' )[ 1 ]); const u8 = Uint8Array . from ( b64 . split ( '' ), e => e . charCodeAt ()); return new Blob ([ u8 ], { type : 'image/png' }); } // Download Button downloadBtn . addEventListener ( 'click' , function ( e ){ let data = hiddenCanvas . toDataURL (); let url = URL . createObjectURL ( dataUriToBlob ( data )); let link = document . createElement ( \"a\" ); link . href = url ; link . download = \"processed.png\" ; link . click (); }) function changeDisabled () { if ( document . getElementsByName ( \"method\" )[ 2 ]. checked ) { resizeSize [ 0 ]. disabled = false ; resizeSize [ 1 ]. disabled = false ; } else { resizeSize [ 0 ]. disabled = true ; resizeSize [ 1 ]. disabled = true ; } } window . onload = changeDisabled (); css ul { list-style : none ; } label { display : inline-flex ; margin-bottom : 0 ; }","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-10.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-10.html"},{"title":"JS.9 ブロック崩しを作る","text":"作ったもの BREAKOUT START var canvas = document.getElementById(\"canvas\"); var ctx = canvas.getContext(\"2d\"); // パドルのパラメータ var paddleHeight = 10; var paddleWidth = 50; var paddleOffsetBottom = 80; var paddleX = (canvas.width-paddleWidth)/2; // 入力を記録する変数 var rightPressed = false; var leftPressed = false; // ブロックのパラメータ var brickColumnCount = 14; var brickRowCount = 6; var brickColors = [\"#F39800\", \"#FFF100\", \"#8FC31F\"]; var brickWidth = 25; var brickHeight = 10; var brickPadding = 5; var brickOffsetTop = 70; var brickOffsetLeft = 30; // ボールのパラメータ var ballRadius = 5; var x = canvas.width/2; var y = canvas.height-paddleOffsetBottom-brickHeight; var dx = 3; var dy = -3; // スコアを記録する。 var score = 0; var maxscore = 0; for(var r=0; r<brickRowCount; r++) { for(var c=0; c<brickColumnCount; c++) { maxscore += 3-Math.floor(r/2); } } // ライフを記録する。 var lives = 3; // 経過時間を記録する関数 var start_time;// グローバル変数にしている。 var timer=0; // 3桁の数字で表示するため var addZero = function(value){ if (value<10) { value = '00' + value; }else if (value<100){ value = '0' + value; } return value; } // イベント開始の関数 function startTimer(){ start_time = new Date(); setInterval(goTimer, 10); } // この関数をループさせる。 function goTimer(){ var milli = new Date() - start_time; var seconds = Math.floor(milli / 1000); seconds = addZero(seconds); timer = seconds; } // ブロックが当たった後に消えるようにする。 var bricks = []; for(var r=0; r<brickRowCount; r++) { bricks[r] = []; for(var c=0; c<brickColumnCount; c++) { // statusでブロックが崩されたかを記憶する。 bricks[r][c] = { x: 0, y: 0, status: 1 }; } } // ボタンの処理で制御する document.addEventListener(\"keydown\", keyDownHandler, false); document.addEventListener(\"keyup\", keyUpHandler, false); // ボタンが押された時のイベント(変数をTrueにする) function keyDownHandler(e) { if(e.key == \"Right\" || e.key == \"ArrowRight\") { rightPressed = true; } else if(e.key == \"Left\" || e.key == \"ArrowLeft\") { leftPressed = true; } } // ボタンが押されなくなった時のイベント(変数をfalseに戻す) function keyUpHandler(e) { if(e.key == \"Right\" || e.key == \"ArrowRight\") { rightPressed = false; } else if(e.key == \"Left\" || e.key == \"ArrowLeft\") { leftPressed = false; } } // マウスの位置で制御する document.addEventListener(\"mousemove\", mouseMoveHandler, false); // マウスが動いた時のイベント。マウスのx座標がキャンバスのx座標内にあれば、その位置に持ってくる。 function mouseMoveHandler(e) { var relativeX = e.clientX - canvas.offsetLeft; if(relativeX>0){ if(relativeX<canvas.width) { paddleX = relativeX - paddleWidth/2; } } } // 音を鳴らす。 function sound(tag){ document.getElementById(tag).currentTime = 0; document.getElementById(tag).play(); } // 衝突を検知する。 function collisionDetection() { for(var r=0; r<brickRowCount; r++) { for(var c=0; c<brickColumnCount; c++) { var b = bricks[r][c]; if(b.status == 1) { // ブロックが存在しているかを確認する。 if(x>b.x){ if (x<b.x+brickWidth){ if (y>b.y){ if (y<b.y+brickHeight){ dy = -dy; if (Math.floor(Math.random() * Math.floor(8)) == 0){ sound(\"soundUp\"); if (dy>0){ dy += 1; }else{ dy -= 1; } } b.status = 0; score+=3-Math.floor(r/2); sound(\"soundBrick\"); // 全てのブロックを崩した場合 if(score == maxscore) { alert(\"YOU WIN\\nYour Time is \" + timer); document.location.reload(); } } } } } } } } } function drawBall() { ctx.beginPath(); ctx.arc(x, y, ballRadius, 0, Math.PI*2); ctx.fillStyle = \"#ffffff\"; ctx.fill(); ctx.closePath(); } function drawPaddle() { ctx.beginPath(); ctx.rect(paddleX, canvas.height-paddleHeight-paddleOffsetBottom, paddleWidth, paddleHeight); ctx.fillStyle = \"#ffffff\"; ctx.fill(); ctx.closePath(); } // ブロックを1つずつ描画する。 function drawBricks() { for(var r=0; r<brickRowCount; r++) { for(var c=0; c<brickColumnCount; c++) { if(bricks[r][c].status == 1) { var brickX = (c*(brickWidth+brickPadding))+brickOffsetLeft; var brickY = (r*(brickHeight+brickPadding))+brickOffsetTop; bricks[r][c].x = brickX; bricks[r][c].y = brickY; ctx.beginPath(); ctx.rect(brickX, brickY, brickWidth, brickHeight); ctx.fillStyle = brickColors[Math.floor(r/2)]; ctx.fill(); ctx.closePath(); } } } } function drawScore() { ctx.font = \"30px 'Comic Sans MS'\"; ctx.fillStyle = \"#ffffff\"; ctx.fillText(score, 30, 40); } function drawTime() { ctx.font = \"30px 'Comic Sans MS'\"; ctx.fillStyle = \"#ffffff\"; ctx.fillText(timer, canvas.width/2-30, 40); } function drawLives() { ctx.font = \"30px 'Comic Sans MS'\"; ctx.fillStyle = \"#ffffff\"; ctx.fillText(lives, canvas.width-65, 40); } function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); // 毎フレームごとに削除 drawBricks(); drawBall(); drawPaddle(); drawScore(); drawTime(); drawLives(); collisionDetection(); // 左端と右端で弾ませる(ボールの半径を考える) if(x + dx>canvas.width-ballRadius || x + dx<ballRadius) { sound(\"soundBar\"); dx = -dx; } // 上端で弾ませる(ボールの半径を考える) if(y + dy<ballRadius) { sound(\"soundBar\"); dy = -dy; } // ボールがパドルの位置に到達した時 else if(y+dy>canvas.height-paddleOffsetBottom-ballRadius){ if (y+dy<canvas.height-paddleOffsetBottom-ballRadius+brickHeight) { // ボールのx座標がパドル上にあれば、跳ね返る if(x>paddleX){ if(x<paddleX + paddleWidth){ sound(\"soundBar\"); dy = -dy; } } } // ボールが下端に到達した時 if(y + dy>canvas.height-ballRadius){ sound(\"soundFail\"); lives--; // 残機がなくなれば失敗する。 if(!lives) { alert(\"YOU LOSE\"); document.location.reload(); } else { x = canvas.width/2; y = canvas.height-paddleOffsetBottom-brickHeight; dx = 3; dy = -3; paddleX = (canvas.width-paddleWidth)/2; } } } // パドルの移動指定されたピクセルだけ動く if(rightPressed){ if(paddleX<canvas.width-paddleWidth) { paddleX += 5; } } else if(leftPressed){ if (paddleX>0) { paddleX -= 5; } } x += dx; y += dy; requestAnimationFrame(draw); } function setCanvas() { drawBricks(); drawBall(); drawPaddle(); drawScore(); drawTime(); drawLives(); } // 初期状態を描いて待機 setCanvas(); function gameButton() { draw(); document.getElementById(\"start\").innerHTML = \"SPEED UP\"; document.getElementById(\"start\").style.fontSize = \"10px\"; } @import url('https://fonts.googleapis.com/css?family=Press+Start+2P&amp;display=swap'); .breakout { text-align: center; margin: 0 auto; font-family: 'Press Start 2P', cursive; } canvas { background: #000; display: block; border: solid 1.0px #eeeeee; margin: 0 auto; } .btn-circle-border-double { display: inline-block; text-decoration: none; color: #000000; width: 100px; height: 100px; line-height: 100px; border-radius: 50%; border: double 4px #000000; text-align: center; overflow: hidden; transition: .6s; } .btn-circle-border-double:hover { -webkit-transform: rotateY(360deg); transform: rotateY(360deg); } 動機 「ゲームを作る」ということが JavaScript の熟達度合いを測る良い指標になると聞いたので、試しにブロック崩しを作ってみた。見た目は1979年に任天堂が発売したブロック崩しを参考にしている。当時のゲームのように、5種類作ることも考えたが、とりあえずシンプルなものだけ作成した。 コード ゲームを作る上でのポイントは以下の関数で、これによってボールが動いているように見せています。 var canvas = document . getElementById ( \"Canvas id\" ); var context = canvas . getContext ( \"2d\" ); // これが重要。キャンバスに描画した指定範囲内の絵を削除している context . clearRect ( 0 , 0 , canvas . width , canvas . height ); html < div class = \"breakout\" > < header > BREAKOUT </ header > < canvas id = \"canvas\" width = \"480\" height = \"500\" ></ canvas > < a id = \"start\" onclick = \"gameButton();startTimer()\" class = \"btn-circle-border-double\" > START </ a > < audio id = \"soundBrick\" src = \"https://taira-komori.jpn.org/sfxr/sfxrse/02laser/shoot01.mp3\" type = \"audio/mp3\" preload = \"auto\" ></ audio > < audio id = \"soundBar\" src = \"https://taira-komori.jpn.org/sfxr/sfxrse/02laser/shoot03.mp3\" type = \"audio/mp3\" preload = \"auto\" ></ audio > < audio id = \"soundFail\" src = \"https://taira-komori.jpn.org/sfxr/sfxrse/04powerup/powerdown02.mp3\" type = \"audio/mp3\" preload = \"auto\" ></ audio > < audio id = \"soundUp\" src = \"https://taira-komori.jpn.org/sfxr/sfxrse/04powerup/powerup05.mp3\" type = \"audio/mp3\" preload = \"auto\" ></ audio > </ div > javascript var canvas = document . getElementById ( \"canvas\" ); var ctx = canvas . getContext ( \"2d\" ); // パドルのパラメータ var paddleHeight = 10 ; var paddleWidth = 50 ; var paddleOffsetBottom = 80 ; var paddleX = ( canvas . width - paddleWidth ) / 2 ; // 入力を記録する変数 var rightPressed = false ; var leftPressed = false ; // ブロックのパラメータ var brickColumnCount = 14 ; var brickRowCount = 6 ; var brickColors = [ \"#F39800\" , \"#FFF100\" , \"#8FC31F\" ]; var brickWidth = 25 ; var brickHeight = 10 ; var brickPadding = 5 ; var brickOffsetTop = 70 ; var brickOffsetLeft = 30 ; // ボールのパラメータ var ballRadius = 5 ; var x = canvas . width / 2 ; var y = canvas . height - paddleOffsetBottom - brickHeight ; var dx = 3 ; var dy = - 3 ; // スコアを記録する。 var score = 0 ; var maxscore = 0 ; for ( var r = 0 ; r < brickRowCount ; r ++ ) { for ( var c = 0 ; c < brickColumnCount ; c ++ ) { maxscore += 3 - Math . floor ( r / 2 ); } } // ライフを記録する。 var lives = 3 ; // 経過時間を記録する関数 var start_time ; // グローバル変数にしている。 var timer = 0 ; // 3桁の数字で表示するため var addZero = function ( value ){ if ( value < 10 ) { value = '00' + value ; } else if ( value < 100 ){ value = '0' + value ; } return value ; } // イベント開始の関数 function startTimer (){ start_time = new Date (); setInterval ( goTimer , 10 ); } // この関数をループさせる。 function goTimer (){ var milli = new Date () - start_time ; var seconds = Math . floor ( milli / 1000 ); seconds = addZero ( seconds ); timer = seconds ; } // ブロックが当たった後に消えるようにする。 var bricks = []; for ( var r = 0 ; r < brickRowCount ; r ++ ) { bricks [ r ] = []; for ( var c = 0 ; c < brickColumnCount ; c ++ ) { // statusでブロックが崩されたかを記憶する。 bricks [ r ][ c ] = { x : 0 , y : 0 , status : 1 }; } } // ボタンの処理で制御する document . addEventListener ( \"keydown\" , keyDownHandler , false ); document . addEventListener ( \"keyup\" , keyUpHandler , false ); // ボタンが押された時のイベント(変数をTrueにする) function keyDownHandler ( e ) { if ( e . key == \"Right\" || e . key == \"ArrowRight\" ) { rightPressed = true ; } else if ( e . key == \"Left\" || e . key == \"ArrowLeft\" ) { leftPressed = true ; } } // ボタンが押されなくなった時のイベント(変数をfalseに戻す) function keyUpHandler ( e ) { if ( e . key == \"Right\" || e . key == \"ArrowRight\" ) { rightPressed = false ; } else if ( e . key == \"Left\" || e . key == \"ArrowLeft\" ) { leftPressed = false ; } } // マウスの位置で制御する document . addEventListener ( \"mousemove\" , mouseMoveHandler , false ); // マウスが動いた時のイベント。マウスのx座標がキャンバスのx座標内にあれば、その位置に持ってくる。 function mouseMoveHandler ( e ) { var relativeX = e . clientX - canvas . offsetLeft ; if ( relativeX > 0 ){ if ( relativeX < canvas . width ) { paddleX = relativeX - paddleWidth / 2 ; } } } // 音を鳴らす。 function sound ( tag ){ document . getElementById ( tag ). currentTime = 0 ; document . getElementById ( tag ). play (); } // 衝突を検知する。 function collisionDetection () { for ( var r = 0 ; r < brickRowCount ; r ++ ) { for ( var c = 0 ; c < brickColumnCount ; c ++ ) { var b = bricks [ r ][ c ]; if ( b . status == 1 ) { // ブロックが存在しているかを確認する。 if ( x > b . x ){ if ( x < b . x + brickWidth ){ if ( y > b . y ){ if ( y < b . y + brickHeight ){ dy = - dy ; if ( Math . floor ( Math . random () * Math . floor ( 8 )) == 0 ){ sound ( \"soundUp\" ); if ( dy > 0 ){ dy += 1 ; } else { dy -= 1 ; } } b . status = 0 ; score += 3 - Math . floor ( r / 2 ); sound ( \"soundBrick\" ); // 全てのブロックを崩した場合 if ( score == maxscore ) { alert ( \"YOU WIN\\nYour Time is \" + timer ); document . location . reload (); } } } } } } } } } function drawBall () { ctx . beginPath (); ctx . arc ( x , y , ballRadius , 0 , Math . PI * 2 ); ctx . fillStyle = \"#ffffff\" ; ctx . fill (); ctx . closePath (); } function drawPaddle () { ctx . beginPath (); ctx . rect ( paddleX , canvas . height - paddleHeight - paddleOffsetBottom , paddleWidth , paddleHeight ); ctx . fillStyle = \"#ffffff\" ; ctx . fill (); ctx . closePath (); } // ブロックを1つずつ描画する。 function drawBricks () { for ( var r = 0 ; r < brickRowCount ; r ++ ) { for ( var c = 0 ; c < brickColumnCount ; c ++ ) { if ( bricks [ r ][ c ]. status == 1 ) { var brickX = ( c * ( brickWidth + brickPadding )) + brickOffsetLeft ; var brickY = ( r * ( brickHeight + brickPadding )) + brickOffsetTop ; bricks [ r ][ c ]. x = brickX ; bricks [ r ][ c ]. y = brickY ; ctx . beginPath (); ctx . rect ( brickX , brickY , brickWidth , brickHeight ); ctx . fillStyle = brickColors [ Math . floor ( r / 2 )]; ctx . fill (); ctx . closePath (); } } } } function drawScore () { ctx . font = \"30px 'Comic Sans MS'\" ; ctx . fillStyle = \"#ffffff\" ; ctx . fillText ( score , 30 , 40 ); } function drawTime () { ctx . font = \"30px 'Comic Sans MS'\" ; ctx . fillStyle = \"#ffffff\" ; ctx . fillText ( timer , canvas . width / 2 - 30 , 40 ); } function drawLives () { ctx . font = \"30px 'Comic Sans MS'\" ; ctx . fillStyle = \"#ffffff\" ; ctx . fillText ( lives , canvas . width - 65 , 40 ); } function draw () { ctx . clearRect ( 0 , 0 , canvas . width , canvas . height ); // 毎フレームごとに削除 drawBricks (); drawBall (); drawPaddle (); drawScore (); drawTime (); drawLives (); collisionDetection (); // 左端と右端で弾ませる(ボールの半径を考える) if ( x + dx > canvas . width - ballRadius || x + dx < ballRadius ) { sound ( \"soundBar\" ); dx = - dx ; } // 上端で弾ませる(ボールの半径を考える) if ( y + dy < ballRadius ) { sound ( \"soundBar\" ); dy = - dy ; } // ボールがパドルの位置に到達した時 else if ( y + dy > canvas . height - paddleOffsetBottom - ballRadius ){ if ( y + dy < canvas . height - paddleOffsetBottom - ballRadius + brickHeight ) { // ボールのx座標がパドル上にあれば、跳ね返る if ( x > paddleX ){ if ( x < paddleX + paddleWidth ){ sound ( \"soundBar\" ); dy = - dy ; } } } // ボールが下端に到達した時 if ( y + dy > canvas . height - ballRadius ){ sound ( \"soundFail\" ); lives -- ; // 残機がなくなれば失敗する。 if ( ! lives ) { alert ( \"YOU LOSE\" ); document . location . reload (); } else { x = canvas . width / 2 ; y = canvas . height - paddleOffsetBottom - brickHeight ; dx = 3 ; dy = - 3 ; paddleX = ( canvas . width - paddleWidth ) / 2 ; } } } // パドルの移動指定されたピクセルだけ動く if ( rightPressed ){ if ( paddleX < canvas . width - paddleWidth ) { paddleX += 5 ; } } else if ( leftPressed ){ if ( paddleX > 0 ) { paddleX -= 5 ; } } x += dx ; y += dy ; requestAnimationFrame ( draw ); } function setCanvas () { drawBricks (); drawBall (); drawPaddle (); drawScore (); drawTime (); drawLives (); } // 初期状態を描いて待機 setCanvas (); function gameButton () { draw (); document . getElementById ( \"start\" ). innerHTML = \"SPEED UP\" ; document . getElementById ( \"start\" ). style . fontSize = \"10px\" ; } css @ import url ( 'https://fonts.googleapis.com/css?family=Press+Start+2P&display=swap' ) ; . breakout { text-align : center ; margin : 0 auto ; font-family : 'Press Start 2P' , cursive ; } canvas { background : #000 ; display : block ; border : solid 1.0 px #eeeeee ; margin : 0 auto ; } . btn-circle-border-double { display : inline-block ; text-decoration : none ; color : #000000 ; width : 100 px ; height : 100 px ; line-height : 100 px ; border-radius : 50 % ; border : double 4 px #000000 ; text-align : center ; overflow : hidden ; transition : .6 s ; } . btn-circle-border-double : hover { -webkit- transform : rotateY ( 360 deg ); transform : rotateY ( 360 deg ); }","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-9.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-9.html"},{"title":"JS.8 Webカメラの映像で遊んでみる-2","text":"それでは、Webカメラの映像をモデルに通して遊んでみたいと思います。GitHub Pages は静的サイトなので、基本的には Python ファイルを動かすことができないのですが、 TensorFlow.js というライブラリを使うことで静的サイトでも機械学習のモデルを使うことができます。 それはまたの機会にやってみるとして、ここではサーバーにWebカメラの映像を送る、といったことをしたいと思います。 この時、動画はフレームの重ね合わせなので、一定時間ごとのフレームを送る、という方法をとります。 まずは、 Canvas タグに動画のフレームを描画することをやってみます。 Webカメラの動画のフレームをCanvasに描画する Streaming STOP Canvas var video = document.getElementById(\"video\"); var media = navigator.mediaDevices.getUserMedia({ video: { facingMode: \"user\" }, audio: false, }); media.then((stream) => { video.srcObject = stream; setInterval(function() { var canvas = document.getElementById('canvas'); var context = canvas.getContext('2d'); var w = video.offsetWidth; canvas.setAttribute('width', w.toString()); var h = video.offsetHeight; canvas.setAttribute('height', h.toString()); context.drawImage(video, 0, 0, w, h); },1000); }); document.getElementById('start_stop').addEventListener('click', function() { var video = document.getElementById('video'); if (this.innerHTML === 'START'){ // ボタン操作 this.innerHTML = 'STOP'; this.classList.remove('btn-blue'); this.classList.add('btn-red'); // ビデオ操作 video.play() } else { this.innerHTML = \"START\"; this.classList.remove('btn-red'); this.classList.add('btn-blue'); video.pause() } }); .video-streaming { text-align: center; margin: 30px auto; } #video { border: 2px solid; border-color: rgb(68, 122, 178); width: 80%; height: auto; } #canvas { border: 2px solid; border-color: rgb(252, 92, 84); width: 80%; height: auto; } .btn-blue { background-color: rgb(68, 122, 178); color: #fff; padding: 10px; border-radius: 3px; } .btn-red { background-color: rgb(252, 92, 84); color: #fff; padding: 10px; border-radius: 3px; } コード html < div class = \"video-streaming\" > < h3 > Streaming </ h3 > < video id = \"video\" width = \"640\" height = \"480\" playsinline muted autoplay ></ video >< br > < h3 > Canvas </ h3 > < canvas id = \"canvas\" ></ canvas >< br > </ div > JavaScript var video = document . getElementById ( \"video\" ); var media = navigator . mediaDevices . getUserMedia ({ video : { facingMode : \"user\" }, audio : false , }); media . then (( stream ) => { video . srcObject = stream ; setInterval ( function () { var canvas = document . getElementById ( 'canvas' ); var context = canvas . getContext ( '2d' ); var w = video . offsetWidth ; canvas . setAttribute ( 'width' , w . toString ()); var h = video . offsetHeight ; canvas . setAttribute ( 'height' , h . toString ()); context . drawImage ( video , 0 , 0 , w , h ); }, 1000 ); //1000ms(=1s)毎に描画しています。 }); css . video-streaming { text-align : center ; margin : 30 px auto ; } # video { border : 2 px solid ; border-color : rgb ( 68 , 122 , 178 ); width : 80 % ; height : auto ; } # canvas { border : 2 px solid ; border-color : rgb ( 252 , 92 , 84 ); width : 80 % ; height : auto ; } . btn-blue { background-color : rgb ( 68 , 122 , 178 ); color : #fff ; padding : 10 px ; border-radius : 3 px ; } . btn-red { background-color : rgb ( 252 , 92 , 84 ); color : #fff ; padding : 10 px ; border-radius : 3 px ; }","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-8.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-8.html"},{"title":"JS.7 Webカメラの映像で遊んでみる-1","text":"やっぱり機械学習エンジニア、それも現在 Neural Pocket で画像認識をしているとなると、やはりWebカメラの映像を使って遊んでみたくなります。 ここでは、以下の流れでやっていきます。 Webカメラの映像をそのままブラウザに表示する。 Webカメラの動画のフレームをCanvasに描画する。 ローカルでPythonファイルを実行し、Webカメラの映像にモデルを適用する。 ローカルホストで取得したWebカメラの映像を機械学習モデルのあるサーバーに送り、結果を受け取って表示する。 どちらもサーバーにあげる。（セキュリティの問題ですぐには厳しそう。） Webカメラの映像をそのままブラウザに表示する。 ※ GitHub Pages は静的サイトなので、映像が僕の元に送信される心配はありません。 STOP var video = document.getElementById(\"video\"); var media = navigator.mediaDevices.getUserMedia({ video: true, audio: false, }); media.then((stream) => { video.srcObject = stream; }); document.getElementById('start_stop').addEventListener('click', function() { var video = document.getElementById('video'); if (this.innerHTML === 'START'){ // ボタン操作 this.innerHTML = 'STOP'; this.classList.remove('btn-blue'); this.classList.add('btn-red'); // ビデオ操作 video.play() } else { this.innerHTML = \"START\"; this.classList.remove('btn-red'); this.classList.add('btn-blue'); video.pause() } }); .video-streaming { text-align: center; margin: 30px auto; } #video { border: 1px solid; } .btn-blue { background-color: rgb(68, 122, 178); color: #fff; padding: 10px; border-radius: 3px; } .btn-red { background-color: rgb(252, 92, 84); color: #fff; padding: 10px; border-radius: 3px; } @media only screen and (max-width: 640px) { #video { width: 100%; height: 100%; } } コード html <!--サイズの初期値は640×480(4:3)--> < video id = \"video\" width = \"640\" height = \"480\" autoplay style = \"border: 1px solid; margin: 0 auto\" ></ video > JavaScript //動画流す準備 var video = document . getElementById ( \"video\" ); // getUserMedia によるカメラ映像の取得 var media = navigator . mediaDevices . getUserMedia ({ video : true , //ビデオを取得する //使うカメラをインカメラか背面カメラかを指定する場合には //video: { facingMode: \"environment\" },//背面カメラ //video: { facingMode: \"user\" },//インカメラ audio : false , //音声が必要な場合はture }); //リアルタイムに再生（ストリーミング）させるためにビデオタグに流し込む media . then (( stream ) => { video . srcObject = stream ; }); css . video-streaming { text-align : center ; margin : 30 px auto ; } # video { border : 1 px solid ; } . btn-blue { background-color : rgb ( 68 , 122 , 178 ); color : #fff ; padding : 10 px ; border-radius : 3 px ; } . btn-red { background-color : rgb ( 252 , 92 , 84 ); color : #fff ; padding : 10 px ; border-radius : 3 px ; } @ media only screen and ( max-width : 640px ) { # video { width : 100 % ; height : 100 % ; } }","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-7.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-7.html"},{"title":"JS.6 隠しコマンドで遊ぶ","text":"JavaScript を使うと隠しコマンドで遊べると聞いたので、試しに遊んで見ました。 また、 fontBomb という、テキスト（フォント）を時限爆弾で爆発させるスクリプトを使って遊んでも見たので、隠しコマンドがわかった人はそれでも遊んでみてください！！ ちなみに、隠しコマンドは僕の名前（ Lastname , Firstname ）です。（間に何もいりません。） 作ったもの 隠しコマンドを解けば、ここにある歌の歌詞が出てきます。その曲を選んだのは僕が好きだからですが、 公式MV に出てくる女性はめちゃめちゃ鍛えた体してるのにボクシングのパンチがありえん\b棒立ちでちょっと残念なので、ぜひ見てみてください！（エドシーランは普通に上手です。） ちなみに、僕は普通のものよりピッチやテンポを上げたアレンジ版の方が好きです。 Shape of You Ed Sheeran [Verse 1] The club isn't the best place to find a lover So the bar is where I go Me and my friends at the table doing shots Drinking fast and then we talk slow And you come over and start up a conversation with just me And trust me I'll give it a chance now Take my hand, stop, put Van the Man on the jukebox And then we start to dance, and now I'm singing like [Pre-Chorus] Girl, you know I want your love Your love was handmade for somebody like me Come on now, follow my lead I may be crazy, don't mind me Say, boy, let's not talk too much Grab on my waist and put that body on me Come on now, follow my lead Come, come on now, follow my lead [Chorus] I'm in love with the shape of you We push and pull like a magnet do Although my heart is falling too I'm in love with your body And last night you were in my room And now my bed sheets smell like you Every day discovering something brand new I'm in love with your body Oh—I—oh—I—oh—I—oh—I I'm in love with your body Oh—I—oh—I—oh—I—oh—I I'm in love with your body Oh—I—oh—I—oh—I—oh—I I'm in love with your body Every day discovering something brand new I'm in love with the shape of you [Verse 2] One week in we let the story begin We're going out on our first date You and me are thrifty, so go all you can eat Fill up your bag and I fill up a plate We talk for hours and hours about the sweet and the sour And how your family is doing okay Leave and get in a taxi, then kiss in the backseat Tell the driver make the radio play, and I'm singing like [Pre-Chorus] Girl, you know I want your love Your love was handmade for somebody like me Come on now, follow my lead I may be crazy, don't mind me Say, boy, let's not talk too much Grab on my waist and put that body on me Come on now, follow my lead Come, come on now, follow my lead [Chorus] I'm in love with the shape of you We push and pull like a magnet do Although my heart is falling too I'm in love with your body And last night you were in my room And now my bed sheets smell like you Every day discovering something brand new I'm in love with your body Oh—I—oh—I—oh—I—oh—I I'm in love with your body Oh—I—oh—I—oh—I—oh—I I'm in love with your body Oh—I—oh—I—oh—I—oh—I I'm in love with your body Every day discovering something brand new I'm in love with the shape of you [Bridge] Come on, be my baby, come on Come on, be my baby, come on Come on, be my baby, come on Come on, be my baby, come on Come on, be my baby, come on Come on, be my baby, come on Come on, be my baby, come on Come on, be my baby, come on [Chorus] I'm in love with the shape of you We push and pull like a magnet do Although my heart is falling too I'm in love with your body Last night you were in my room And now my bed sheets smell like you Every day discovering something brand new I'm in love with your body Come on, be my baby, come on Come on, be my baby, come on I'm in love with your body Come on, be my baby, come on Come on, be my baby, come on I'm in love with your body Come on, be my baby, come on Come on, be my baby, come on I'm in love with your body Every day discovering something brand new I'm in love with the shape of you $(function() { var inputKey = []; var Command = [73,87,65,83,65,75,73,83,72,85,84,79]; var fontbomb_script = document.createElement('script'); $(window).keyup(function(e) { inputKey.push(e.keyCode); // 入力配列にコマンドがあるかを調べる。存在しなければ-1を返す。 if (inputKey.toString().indexOf(Command) >= 0) { //隠しコマンド成功時 alert(\"コマンド発動！！\"); // cssにbackground-imageを記述したクラスを追加(これで背景を変える。) $(\"#shape-of-you\").addClass('shape-of-you'); document.querySelector('#shape-of-you').style.visibility = \"visible\"; // fontbombをscriptに追加 var s = document.createElement('script'); s.setAttribute('src', 'https://iwasakishuto.github.io/js/fontbomb.js'); document.body.appendChild(s); //キー入力を初期化 inputKey = []; } if (inputKey.length >= 1000){ alert(\"かなり頑張ってますね笑\\n処理速度を上げるために初期化しますね！\"); inputKey = []; } }); }); .shape-of-you { background-color: rgb(170, 220, 230); background-size:contain; width:100%; } コード html < div id = \"shape-of-you\" style = \"visibility: hidden;\" > <!-- ここに\b隠しコマンド後に表示させる要素をかく --> </ div > < script src = \"https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js\" ></ script > JavaScript $ ( function () { var inputKey = []; var Command = [ 73 , 87 , 65 , 83 , 65 , 75 , 73 , 83 , 72 , 85 , 84 , 79 ]; $ ( window ). keyup ( function ( e ) { inputKey . push ( e . keyCode ); // 入力配列にコマンドがあるかを調べる。存在しなければ-1を返す。 if ( inputKey . toString (). indexOf ( Command ) >= 0 ) { //隠しコマンド成功時 alert ( \"コマンド発動！！\" ); // cssにbackground-imageを記述したクラスを追加(これで背景を変える。) $ ( \"#shape-of-you\" ). addClass ( 'shape-of-you' ); document . querySelector ( '#shape-of-you' ). style . visibility = \"visible\" ; // fontBombのスクリプトをコピー var s = document . createElement ( 'script' ); s . setAttribute ( 'src' , 'http://fontbomb.ilex.ca/js/main.js' ); document . body . appendChild ( s ); //キー入力を初期化 inputKey = []; } if ( inputKey . length >= 1000 ){ alert ( \"かなり頑張ってますね笑\\n処理速度を上げるために初期化しますね！\" ); inputKey = []; } }); css . shape-of-you { background-color : rgb ( 170 , 220 , 230 ); background-size : contain ; width : 100 % ; }","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-6.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-6.html"},{"title":"JS.5 ビンゴマシーン","text":"動機 音声の取り扱い方、表示/非表示のやり方を試すために、ビンゴマシーンを作成しました。 作成したきっかけは、知り合いのエンジニアの結婚式の際に、新郎の方が即席でプログラムを書いてビンゴを行なったと聞き、そういった要望をすぐにかなえられたらカッコいいなと思ったからです。（結婚式会場にパソコン持っていくのは流石優秀なエンジニアだなと思いましたが…笑） なお、調べれば色々な方がビンゴマシーンを作成しているので、 ビンゴマシーン javascript とかで検索して見てください。 作ったもの まずは、最大値を決めてビンゴマシーンを作成してください！\b普通の市販のビンゴは最大値が 75 になっていると思います。 生成 START var max, bingo = [], $number = $(\"#number\"), $result = $(\"#result\"), $sound_play = $(\"#sound-play\"), $sound_pause = $(\"#sound-pause\"); // ビンゴマシーンを作成する。 function generateBINGO(){ max = document.querySelector('#max-num').value; for(var i = 1; i <= max; i++) { bingo.push(i); $number.append($(\"<li>\").text((\"0\" + i).slice(-2))); } document.querySelector('#bingo-info').style.display = \"none\"; document.querySelector('#bingo-machine').style.display = \"block\"; window.alert('最大値'+max+'でビンゴマシーンが生成されました！\\nSTARTボタンを押してビンゴを始めてみてください！！\\n※音が出るので注意してください。') }; $(function(){ var status = true, roulette, random, number, result; $(\"#button\").on(\"click\", function(){ // ルーレットを回す if(status) { status = false; $(this).text(\"STOP\"); $sound_play.trigger(\"play\"); $sound_pause.trigger(\"pause\"); $sound_pause[0].currentTime = 0; roulette = setInterval(function(){ random = Math.floor(Math.random() * bingo.length); number = bingo[random]; $result.text(number); }, 10); // 10ms毎にイベント(数字を回す)を起動。 // ルーレットを止める } else { status = true; $(this).text(\"START\"); $sound_pause.trigger(\"play\"); $sound_play.trigger(\"pause\"); $sound_play[0].currentTime = 0; clearInterval(roulette); // 起動していたイベントを終了 result = bingo[random]; bingo.splice(random, 1); // 配列から削除 $result.text(result); $number.find(\"li\").eq(parseInt(result, 10) - 1).addClass(\"hit\"); } }); }); body { color:#000000; font-family: arial, sans-serif; } .wrapper { text-align: center; margin: 0 auto; } input { padding: 10px; font-size: 1.2em; } .generate { padding: 10px; font-size: 1.2em; border-radius: 3px; background-color: #80160e; color: #ffffff; } .result { align-items: center; border: solid 1px #000000; display: flex; font-size: 130px; font-weight: bold; justify-content: center; height: 200px; margin: 0 auto 10px; text-align: center; width: 200px; } .number { display: flex; flex-wrap: wrap; justify-content: flex-start; margin: 0 auto; list-style: none; padding: 0; width: 500px; } @media (max-width: 767px) { .number { width: 100%; } } .number li { align-items: center; border: solid 1px #000000; display: flex; justify-content: center; height: 40px; margin: 4px; width: 40px; } .number li.hit { background: #80160e; color: #fff; } .wrapper-button { padding: 20px 0 50px; text-align: center; } .button { background: #80160e; border: dashed 1px #ffffff; border-radius: 50%; box-shadow: 0 0 0 5px #80160e; color: #ffffff; display: inline-block; font-size: 20px; text-decoration: none; height: 100px; line-height: 100px; overflow: hidden; text-align: center; transition: .4s; vertical-align: middle; width: 100px; } .button:hover { background: #f0d0d0; box-shadow: 0 0 0 5px #b87069; cursor: pointer; } footer { text-align: center; } コード html < div class = \"wrapper\" > < div id = \"bingo-info\" style = \"display: block;\" > < input id = \"max-num\" type = \"number\" min = \"1\" max = \"99\" value = \"75\" /> < button type = \"button\" class = \"generate\" onclick = \"generateBINGO()\" > 生成 </ button > </ div > < div id = \"bingo-machine\" style = \"display: none;\" > < div id = \"result\" class = \"result\" ></ div > < ul id = \"number\" class = \"number\" ></ ul > < div class = \"wrapper-button\" > < button id = \"button\" class = \"button\" > START </ button > </ div > < audio id = \"sound-play\" preload = \"auto\" > < source src = \"https://raw.githubusercontent.com/miiitaka/game-bingo/master/start.mp3\" type = \"audio/mp3\" > </ audio > < audio id = \"sound-pause\" preload = \"auto\" > < source src = \"https://raw.githubusercontent.com/miiitaka/game-bingo/master/pause.mp3\" type = \"audio/mp3\" > </ audio > </ div > </ div > < script src = \"https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js\" ></ script > javascript var max , bingo = [], $number = $ ( \"#number\" ), $result = $ ( \"#result\" ), $sound_play = $ ( \"#sound-play\" ), $sound_pause = $ ( \"#sound-pause\" ); // ビンゴマシーンを作成する。 function generateBINGO (){ max = document . querySelector ( '#max-num' ). value ; for ( var i = 1 ; i <= max ; i ++ ) { bingo . push ( i ); $number . append ( $ ( \"<li>\" ). text (( \"0\" + i ). slice ( - 2 ))); } document . querySelector ( '#bingo-info' ). style . display = \"none\" ; document . querySelector ( '#bingo-machine' ). style . display = \"block\" ; window . alert ( '最大値' + max + 'でビンゴマシーンが生成されました！\\nSTARTボタンを押してビンゴを始めてみてください！！\\n※音が出るので注意してください。' ) }; $ ( function (){ var status = true , roulette , random , number , result ; $ ( \"#button\" ). on ( \"click\" , function (){ // ルーレットを回す if ( status ) { status = false ; $ ( this ). text ( \"STOP\" ); $sound_play . trigger ( \"play\" ); $sound_pause . trigger ( \"pause\" ); $sound_pause [ 0 ]. currentTime = 0 ; roulette = setInterval ( function (){ random = Math . floor ( Math . random () * bingo . length ); number = bingo [ random ]; $result . text ( number ); }, 10 ); // 10ms毎にイベント(数字を回す)を起動。 // ルーレットを止める } else { status = true ; $ ( this ). text ( \"START\" ); $sound_pause . trigger ( \"play\" ); $sound_play . trigger ( \"pause\" ); $sound_play [ 0 ]. currentTime = 0 ; clearInterval ( roulette ); // 起動していたイベントを終了 result = bingo [ random ]; bingo . splice ( random , 1 ); // 配列から削除 $result . text ( result ); $number . find ( \"li\" ). eq ( parseInt ( result , 10 ) - 1 ). addClass ( \"hit\" ); } }); }); css body { color : #000000 ; font-family : arial , sans-serif ; } . wrapper { text-align : center ; margin : 0 auto ; } input { padding : 10 px ; font-size : 1.2 em ; } . generate { padding : 10 px ; font-size : 1.2 em ; border-radius : 3 px ; background-color : #80160e ; color : #ffffff ; } . result { align-items : center ; border : solid 1 px #000000 ; display : flex ; font-size : 130 px ; font-weight : bold ; justify-content : center ; height : 200 px ; margin : 0 auto 10 px ; text-align : center ; width : 200 px ; } . number { display : flex ; flex-wrap : wrap ; justify-content : flex-start ; margin : 0 auto ; list-style : none ; padding : 0 ; width : 500 px ; } @ media ( max-width : 767px ) { . number { width : 100 % ; } } . number li { align-items : center ; border : solid 1 px #000000 ; display : flex ; justify-content : center ; height : 40 px ; margin : 4 px ; width : 40 px ; } . number li . hit { background : #80160e ; color : #fff ; } . wrapper-button { padding : 20 px 0 50 px ; text-align : center ; } . button { background : #80160e ; border : dashed 1 px #ffffff ; border-radius : 50 % ; box-shadow : 0 0 0 5 px #80160e ; color : #ffffff ; display : inline-block ; font-size : 20 px ; text-decoration : none ; height : 100 px ; line-height : 100 px ; overflow : hidden ; text-align : center ; transition : .4 s ; vertical-align : middle ; width : 100 px ; } . button : hover { background : #f0d0d0 ; box-shadow : 0 0 0 5 px #b87069 ; cursor : pointer ; } footer { text-align : center ; }","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-5.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-5.html"},{"title":"JS.4 Canvasで遊んでみる","text":"HTML5から追加された Canvas というものを使って、お絵かきアプリを作成しました。 イベントドリブンのものは jquery で、それ以外のものは直の JavaScript で書いたつもりです。だいぶ JavaScript にも慣れてきた!! 作ったもの color: #000000 background-color: #ffffff download Clear All // Canvasの情報 var canvas; var context; // 線の情報 var color; // ページの読み込みが完了したらコールバック関数が呼ばれる window.addEventListener('load', function() { canvas = document.querySelector('#drawing-pad'); context = canvas.getContext('2d'); const lastPosition = { x: null, y: null }; // nullで初期化。 let isDrag = false; // 線を描き続けているかを判断するためのフラグ var draw = function(x, y){ if(!isDrag) { return; } /* 線の情報 */ context.lineCap = 'round'; // 丸みを帯びた線にする context.lineJoin = 'round'; // 丸みを帯びた線にする context.lineWidth = 5; // 線の太さ context.strokeStyle = color; // 線の色 // 開始位置の調整 if (lastPosition.x === null || lastPosition.y === null) { context.moveTo(x, y); } else { context.moveTo(lastPosition.x, lastPosition.y); } // 開始位置から現在の位置を線で結ぶ。 context.lineTo(x, y); // 実際に描画する。 context.stroke(); // 現在の点を次回の開始点にする。 lastPosition.x = x; lastPosition.y = y; } var dragStart = function(e) { // 描画開始を宣言 context.beginPath(); isDrag = true; } var dragEnd = function(e) { // 描画終了を宣言 context.closePath(); isDrag = false; // 開始点をリセット。 lastPosition.x = null; lastPosition.y = null; } // canvas上に書いた絵を全部消す var clear = function() { context.clearRect(0, 0, canvas.width, canvas.height); document.querySelector('#drawing-pad').style.backgroundColor = '#ffffff'; // canvasの背景色 document.querySelector('#color2').innerHTML = '#ffffff'; // 表示されているカラーコード document.querySelector('#color2').style.color = '#ffffff'; // 上の文字色 document.querySelector('#pad-color').value = '#ffffff'; // ボタンの色 } // マウス操作やボタンクリック時のイベント処理を定義する var initEventHandler = function() { canvas.addEventListener('mousedown', dragStart); // マウスボタンを押した時。 canvas.addEventListener('mouseup', dragEnd); // マウスボタンを離した時。 canvas.addEventListener('mouseout', dragEnd); // マウスカーソルが外に出た時。 canvas.addEventListener('mousemove', function(e) { // マウスカーソルが動いた時 draw(e.layerX, e.layerY); }); const clearButton = document.querySelector('#clear-button'); clearButton.addEventListener('click', clear); } // イベント処理を初期化する initEventHandler(); }); $(function(){ // ペンの色を変更 $(function(){ $('#pen-color').on('change', function(){ $('#color1').text($('#pen-color').val()).css('color', $('#pen-color').val()); color = $('#pen-color').val(); }) }); // 背景色を変更 $('#pad-color').on('change', function(){ $('#color2').text($('#pad-color').val()).css('color', $('#pad-color').val()); $('#drawing-pad').css('background-color', $('#pad-color').val()); // 以下の手法だと、描画した画像が上書きされてしまう！ // context.fillStyle = $('#pad-color').val(); // context.fillRect(0, 0, canvas.width, canvas.height); }) // ダウンロード $('#download').on('click', function(){ // メモリ内で新しく画像を描画し、ダウンロードしている。 var mem_canvas = document.createElement(\"canvas\"); mem_canvas.width = canvas.width; mem_canvas.height = canvas.height; var mem_context = mem_canvas.getContext('2d'); // まず、背景色として指定されている色で塗りつぶす。 mem_context.fillStyle = $('#pad-color').val(); mem_context.fillRect(0, 0, canvas.width, canvas.height); // 次に、現在描かれている絵(線)をコピーする。 mem_context.drawImage(canvas,0,0); // それをダウンロード。 let link = document.createElement(\"a\"); link.href = mem_canvas.toDataURL(\"image/png\"); link.download = \"canvas.png\"; link.click(); }) }); .canvas { text-align: center; margin: 30px auto; } .btn-blue { background-color: rgba(68, 122, 178); color: #fff; padding: 10px; border-radius: 3px; } .btn-red { background-color: rgb(252, 92, 84); color: #fff; padding: 10px; border-radius: 3px; } コード < div class = \"canvas\" > <!-- canvasのサイズを変更する場合、スタイルではなく属性で変更しないとおかしくなる！ --> < canvas id = \"drawing-pad\" width = \"400px\" height = \"400px\" style = \"border: 1.5px solid #000; background-color: #ffffff\" ></ canvas > < div > < input id = \"pen-color\" type = \"color\" value = \"#000000\" > color: < span id = \"color1\" > #000000 </ span > </ div > < div > < input id = \"pad-color\" type = \"color\" value = \"#ffffff\" > background-color: < span id = \"color2\" > #ffffff </ span > </ div > < button id = \"download\" class = \"btn-blue\" > download </ button > < button id = \"clear-button\" class = \"btn-red\" > Clear All </ button > </ div > < script src = \"https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js\" ></ script > < script > // Canvasの情報 var canvas ; var context ; // 線の情報 var color ; // ページの読み込みが完了したらコールバック関数が呼ばれる window . addEventListener ( 'load' , function () { canvas = document . querySelector ( '#drawing-pad' ); context = canvas . getContext ( '2d' ); const lastPosition = { x : null , y : null }; // nullで初期化。 let isDrag = false ; // 線を描き続けているかを判断するためのフラグ var draw = function ( x , y ){ if ( ! isDrag ) { return ; } /* 線の情報 */ context . lineCap = 'round' ; // 丸みを帯びた線にする context . lineJoin = 'round' ; // 丸みを帯びた線にする context . lineWidth = 5 ; // 線の太さ context . strokeStyle = color ; // 線の色 // 開始位置の調整 if ( lastPosition . x === null || lastPosition . y === null ) { context . moveTo ( x , y ); } else { context . moveTo ( lastPosition . x , lastPosition . y ); } // 開始位置から現在の位置を線で結ぶ。 context . lineTo ( x , y ); // 実際に描画する。 context . stroke (); // 現在の点を次回の開始点にする。 lastPosition . x = x ; lastPosition . y = y ; } var dragStart = function ( e ) { // 描画開始を宣言 context . beginPath (); isDrag = true ; } var dragEnd = function ( e ) { // 描画終了を宣言 context . closePath (); isDrag = false ; // 開始点をリセット。 lastPosition . x = null ; lastPosition . y = null ; } // canvas上に書いた絵を全部消す var clear = function () { context . clearRect ( 0 , 0 , canvas . width , canvas . height ); document . querySelector ( '#drawing-pad' ). style . backgroundColor = '#ffffff' ; // canvasの背景色 document . querySelector ( '#color2' ). innerHTML = '#ffffff' ; // 表示されているカラーコード document . querySelector ( '#color2' ). style . color = '#ffffff' ; // 上の文字色 document . querySelector ( '#pad-color' ). value = '#ffffff' ; // ボタンの色 } // マウス操作やボタンクリック時のイベント処理を定義する var initEventHandler = function () { canvas . addEventListener ( 'mousedown' , dragStart ); // マウスボタンを押した時。 canvas . addEventListener ( 'mouseup' , dragEnd ); // マウスボタンを離した時。 canvas . addEventListener ( 'mouseout' , dragEnd ); // マウスカーソルが外に出た時。 canvas . addEventListener ( 'mousemove' , function ( e ) { // マウスカーソルが動いた時 draw ( e . layerX , e . layerY ); }); const clearButton = document . querySelector ( '#clear-button' ); clearButton . addEventListener ( 'click' , clear ); } // イベント処理を初期化する initEventHandler (); }); $ ( function (){ // ペンの色を変更 $ ( function (){ $ ( '#pen-color' ). on ( 'change' , function (){ $ ( '#color1' ). text ( $ ( '#pen-color' ). val ()). css ( 'color' , $ ( '#pen-color' ). val ()); color = $ ( '#pen-color' ). val (); }) }); // 背景色を変更 $ ( '#pad-color' ). on ( 'change' , function (){ $ ( '#color2' ). text ( $ ( '#pad-color' ). val ()). css ( 'color' , $ ( '#pad-color' ). val ()); $ ( '#drawing-pad' ). css ( 'background-color' , $ ( '#pad-color' ). val ()); // 以下の手法だと、描画した画像が上書きされてしまう！ // context.fillStyle = $('#pad-color').val(); // context.fillRect(0, 0, canvas.width, canvas.height); }) // ダウンロード $ ( '#download' ). on ( 'click' , function (){ // メモリ内で新しく画像を描画し、ダウンロードしている。 var mem_canvas = document . createElement ( \"canvas\" ); mem_canvas . width = canvas . width ; mem_canvas . height = canvas . height ; var mem_context = mem_canvas . getContext ( '2d' ); // まず、背景色として指定されている色で塗りつぶす。 mem_context . fillStyle = $ ( '#pad-color' ). val (); mem_context . fillRect ( 0 , 0 , canvas . width , canvas . height ); // 次に、現在描かれている絵(線)をコピーする。 mem_context . drawImage ( canvas , 0 , 0 ); // それをダウンロード。 let link = document . createElement ( \"a\" ); link . href = mem_canvas . toDataURL ( \"image/png\" ); link . download = \"canvas.png\" ; link . click (); }) }); </ script > < style > . canvas { text-align : center ; margin : 30 px auto ; } . btn-blue { background-color : rgba ( 68 , 122 , 178 ); color : #fff ; padding : 10 px ; border-radius : 3 px ; } . btn-red { background-color : rgb ( 252 , 92 , 84 ); color : #fff ; padding : 10 px ; border-radius : 3 px ; } </ style >","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-4.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-4.html"},{"title":"JS.3 Ajax通信で遊んでみる","text":"講座： [HTML/CSS/JavaScript] フロントエンドエンジニアになりたい人の Webプログラミング入門 講師： Taniguchi Makoto 色々な書き方 今回は、以下のHTMLを jsonから読み込む 直書きでAjax通信を使う jquery でAjax通信を使う vue.js でAjax通信を使う という方法で作る方法を学びます。 < div id = \"img_unit\" > < div class = \"photo\" > < img src = \"img/img01.jpg\" > < div class = \"inner\" > < p > コメント1 < span > name01 </ span ></ p > </ div > </ div > < div class = \"photo\" > < img src = \"img/img02.jpg\" > < div class = \"inner\" > < p > コメント2 < span > name02 </ span ></ p > </ div > </ div > </ div > なお、それぞれのhtmlファイルを index.html と言う名前だと仮定し以下のようなファイルパス関係だとします。 . ├── index.html └── img ├── img01.jpg ├── img02.jpg └── img03.jpg ちなみに、以下の css を読み込んでおくと綺麗に表示されます。 body { margin : 0 ; padding : 0 ; background-color : rgba ( 26 , 55 , 229 , 0.06 ); } . container { /*\b<div class=\"container\">で上記のhtmlを囲むとより綺麗に表示されます。*/ max-width : 600 px ; margin : 0 auto ; box-shadow : 0 px 0 px 3 px rgba ( 0 , 0 , 0 , .3 ); } img { width : 100 % ; margin 0 ; vertical-align : top ; } . photo { position : relative ; /*親要素に relative とすることで下で absolute が photo に対して行われる。*/ } . photo . inner { position : absolute ; bottom : 0 ; background-color : rgba ( 0 , 0 , 0 , .5 ); font-size : 10 px ; color : #fff ; margin : 0 ; width : 100 % ; } . inner p { padding : 20 px ; } . inner span { margin-left : 10 px ; } json から読み込む Json(JavaScript Object Notation)ファイルにデータを\b用意しておいて、それらを随時読み込んで表示する方式。 以下のどちらを利用するかは自由。 htmlを直接 innerHTML プロパティで挿入する。 createElement や appendChild を使って要素をオブジェクトとして扱う。 < div id = \"img_unit\" > </ div > < script > var images = [ { \"path\" : \"img/img01.jpg\" , \"name\" : \"name01\" , \"caption\" : \"コメント1\" }, { \"path\" : \"img/img02.jpg\" , \"name\" : \"name02\" , \"caption\" : \"コメント2\" }, { \"path\" : \"img/img03.jpg\" , \"name\" : \"name03\" , \"caption\" : \"コメント3\" } ]; var img ; var caption ; var div ; for ( var i = 0 ; i < images . length ; i ++ ){ img = document . createElement ( 'img' ); // <img>タグが\b作られる。 img . setAttribute ( 'src' , images [ i ]. path ); // src属性を追加し、属性値を設定。 caption = document . createElement ( 'div' ); // <div>タグが作られる。 caption . className = 'inner' ; // class属性を追加し、属性値を設定。 caption . innerHTML = '<p>' + images [ i ]. caption + '<span>' + images [ i ]. name + '</span></p>' ; // divタグの中に<p>...</p>という要素を追加。 div = document . createElement ( 'div' ); div . className = 'photo' ; div . appendChild ( img ); // divの内部にimgを追加する。 div . appendChild ( caption ); // divの内部にcaptionを追加する。 document . getElementById ( 'img_unit' ). appendChild ( div ); //\"id=img_unit\"のタグの内部にdivを追加する。 } </ script > 直書きでAjax通信を使う プログラムの中にjsonデータを\b保持しているのは賢いやり方ではない。 というか、API(Application Programing Interface)を使って外部と通信しながらデータを処理することがほとんどであり、その時に使えるのがAjax通信。 なお、ここでは、\"https://h2o-space.com/htmlbook/images.php\" というサーバーと通信を行なっているが、これはjsonのセキュリティの問題のため。 file がCross origin requestsでサポートされているプロトコルに含まれていない（セキュリティ上危ないから）ので、講師の方が用意してくださっている。 また、ajax通信は以下のようにいくつかのステップに分かれており、それぞれに状態が割り当てられている\bので、通信が終わったことを確認してから次の処理を行うことができる。 値 定数 状態 0 UNSENT インスタンスができた 1 OPENED openメソッドを利用した 2 HEADERS_RECEIVED ヘッダーが受信できた 3 LOADING データを受信中である 4 DONE 通信が終了した < div id = \"img_unit\" > </ div > < script > var ajax = new XMLHttpRequest (); //ajax通信を行うためのオブジェクト。XMLはデータ形式の一つだが、ここではJsonでデータのやり取りを行う。 // alert(ajax.readyState); // 0 ajax . open ( 'GET' , 'https://h2o-space.com/htmlbook/images.php' ); // ajax通信を行う相手先のアドレス(講師の方が用意してくださっている。) // alert(ajax.readyState); // 1 (openを行なった後) ajax . responseType = 'json' ; // データの形式を指定 ajax . send ( null ); // ファイルを呼び出す。 ajax . onreadystatechange = function (){ if ( ajax . readyState === XMLHttpRequest . DONE && ajax . status === 200 ){ for ( var i = 0 ; i < this . response . length ; i ++ ){ var data = this . response [ i ]; img = document . createElement ( 'img' ); img . setAttribute ( 'src' , data . path ); caption = document . createElement ( 'div' ); caption . className = 'inner' ; caption . innerHTML = '<p>' + data . caption + '<span>' + data . name + '</span></p>' ; div = document . createElement ( 'div' ); div . className = 'photo' ; div . appendChild ( img ); div . appendChild ( caption ); document . getElementById ( 'img_unit' ). appendChild ( div ); } } }; </ script > jquery でAjax通信を使う jqueryの公式サイト から、jqueryをダウンロードし、 js/jquery.min.js に保存してください。 < div id = \"img_unit\" > </ div > < script src = \"js/jquery.min.js\" ></ script > < script > $ . getJSON ( 'https://h2o-space.com/htmlbook/images.php' , function ( data ) { // コールバック(処理が終わった時に自動的に呼び出されるファイルのこと。) for ( var i = 0 ; i < data . length ; i ++ ){ $ ( '<div class=\"photo\"></div>' ) . append ( '<img src=\"' + data [ i ]. path + '\">' ) // 自分自身「に」追加する。 . append ( '<div class=\"inner\"<p>' + data [ i ]. caption + '<span>' + data [ i ]. name + '</span></p></div>' ) . appendTo ( '#img_unit' ); // 自分自身「を」追加する。 } }); /* サンプル（htmlを生成する。） $(#img_unit).html('ここに、画像リストが表示されます。'); $(#img_unit).css('margin-top', '100px'); */ </ script > vue.js でAjax通信を使う jquery だとhtmlを生成する際に要素をそのままscript内に書いており、少し\bわかりにくかったです。そこで、vue.jsというライブラリがよく使われる。 なお、vue.jsは 公式サイト にてcdn\bで配布されています。 vue,jsは以下の形が基本で、プレースホルダーを\b書き換える、といった操作を行います。 < div id = \"vue_unit\" > {{ message }} </ div > < script > var app = new Vue ({ el : '#vue_unit' , data : { message : 'vue.jsで書き換えました。' } }); </ script > 今までのサンプルに適用すると、以下のようになります。なお、プレースホルダーを属性値の中に書くことができないので、別の書き方をしています。 < div id = \"img_unit\" > < div class = \"photo\" v-for = \"Photo in Photos\" > <!-- vue.js の for構文を使っている。 --> < img :src = \"Photo.path\" > <!-- vue.js によって書き換えられる対象となる。 --> < div class = \"inner\" >< p > {{ Photo.caption }} < span > {{ Photo.name }} </ span ></ p ></ div > </ div > </ div > < script src = \"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\" ></ script > < script src = \"js/jquery.min.js\" ></ script > < script > var app = new Vue ({ el : '#img_unit' , data : { Photos : [] }, created : function () { // vueのオブジェクトが作られる時のメソッド var self = this ; // ここでのスコープのthisを保存しておく。 $ . getJSON ( 'https://h2o-space.com/htmlbook/images.php' , function ( data ) { self . Photos = data }); } }); </ script > 最後に これで、\b講義で習った事は終了しました:)","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-3.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-3.html"},{"title":"JS.2 イベントドリブンなストップウォッチプログラムを作成する","text":"講座： [HTML/CSS/JavaScript] フロントエンドエンジニアになりたい人の Webプログラミング入門 講師： Taniguchi Makoto はじめに 今回は、 setInterval と clearInterval を用いて、イベントドリブンなアプリケーションを作成した。 作ったもの 00:00:00:00 START var start;// グローバル変数にしている。 var timer_id; document.getElementById('start_stop').addEventListener('click', function() { if (this.innerHTML === 'START'){ start = new Date(); timer_id = setInterval(goTimer, 10); // ここで返って来たIDを利用して↓ this.innerHTML = 'STOP'; // this = document.getElementById('start_stop') this.classList.remove('btn-blue'); this.classList.add('btn-red'); } else { clearInterval(timer_id); // ここで止める。 this.innerHTML = \"START\"; this.classList.remove('btn-red'); this.classList.add('btn-blue'); } }); var addZero = function(value){ if (value < 10) { value = '0' + value; } return value; } var goTimer = function(){ var now = new Date(); var milli = now.getTime() - start.getTime(); var seconds = Math.floor(milli / 1000); var minutes = Math.floor(seconds / 60); var hours = Math.floor(minutes / 60); milli = Math.floor((milli - seconds * 1000)/10); seconds = seconds - minutes * 60; minutes = minutes - hours * 60; milli = addZero(milli); seconds = addZero(seconds); minutes = addZero(minutes); hours = addZero(hours); document.getElementById('timer').innerHTML = hours + \":\" + minutes + \":\" + seconds + \":\" + milli; } .stopwatch { text-align: center; margin: 30px auto; } /*idは #で指定する。*/ #timer { font-size: 36px; border: 1px solid #ccc; margin 30px auto; padding: 50px; background-color: #000; color: #fff; border-radius: 3px; box-shadow: 1px 1px 3px rgba(0, 0, 0, .5); } .btn-blue { background-color: rgba(68, 122, 178); color: #fff; padding: 10px; border-radius: 3px; } .btn-red { background-color: rgb(252, 92, 84); color: #fff; padding: 10px; border-radius: 3px; } コード < div class = \"container\" > < p id = \"timer\" > 00:00:00:00 </ p > < div > < button id = \"start_stop\" class = \"btn-blue\" > START </ button > </ div > </ div > < script > var start ; // グローバル変数にしている。 var timer_id ; document . getElementById ( 'start_stop' ). addEventListener ( 'click' , function () { if ( this . innerHTML === 'START' ){ start = new Date (); timer_id = setInterval ( goTimer , 10 ); // ここで返って来たIDを利用して↓ this . innerHTML = 'STOP' ; // this = document.getElementById('start_stop') this . classList . remove ( 'btn-blue' ); this . classList . add ( 'btn-red' ); } else { clearInterval ( timer_id ); // ここで止める。 this . innerHTML = \"START\" ; this . classList . remove ( 'btn-red' ); this . classList . add ( 'btn-blue' ); } }); var addZero = function ( value ){ if ( value < 10 ) { value = '0' + value ; } return value ; } var goTimer = function (){ var now = new Date (); var milli = now . getTime () - start . getTime (); var seconds = Math . floor ( milli / 1000 ); var minutes = Math . floor ( seconds / 60 ); var hours = Math . floor ( minutes / 60 ); milli = Math . floor (( milli - seconds * 1000 ) / 10 ); seconds = seconds - minutes * 60 ; minutes = minutes - hours * 60 ; milli = addZero ( milli ); seconds = addZero ( seconds ); minutes = addZero ( minutes ); hours = addZero ( hours ); document . getElementById ( 'timer' ). innerHTML = hours + \":\" + minutes + \":\" + seconds + \":\" + milli ; } </ script > < style > . container { text-align : center ; margin : 30 px auto ; } /*idは #で指定する。*/ # timer { font-size : 36 px ; border : 1 px solid #ccc ; margin 30px auto ; padding : 50 px ; background-color : #000 ; color : #fff ; border-radius : 3 px ; box-shadow : 1 px 1 px 3 px rgba ( 0 , 0 , 0 , .5 ); } . btn-blue { background-color : rgba ( 68 , 122 , 178 ); color : #fff ; padding : 10 px ; border-radius : 3 px ; } . btn-red { background-color : rgb ( 252 , 92 , 84 ); color : #fff ; padding : 10 px ; border-radius : 3 px ; } </ style >","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-2.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-2.html"},{"title":"JS.1 今日の日付を表示する","text":"講座： [HTML/CSS/JavaScript] フロントエンドエンジニアになりたい人の Webプログラミング入門 講師： Taniguchi Makoto はじめに まずはじめに断っておくと、おそらくプログラミング系の記事は 「誰かに説明する」 と言うよりは、 「自分の備忘録」 として\b書きます :man-bowing: 突然 JavaScript の勉強始めた一番の理由は 「 LGTM の活動の中で力不足を感じたから」 です。 2019/6/1,2に、 FiNC Technologies とハッカソンをさせていただいたのですが、僕ができたのは下の部分だけで、機械学習のAPIを作ったものの、 正直魅せ方ととして芸がないな と感じてしまいました。 この思いは前からずっと感じていたことだったので、 「良いキッカケをもらった」 と思い、早速一から勉強することにしました。 作ったもの 今日の日付を JavaScript を使って表示します。 var today = new Date(); var todayHtml = today.getFullYear() + '/' + (today.getMonth()+1) + '/' + today.getDate(); // getMonth は、1月を0としているので、+1をしている。 // document は、ブラウザが準備してくれたインスタンス。 document.write('<p class=\"date\" style=\"font-size:300%; text-align: center; color: rgb(128,22,14);\">today: ' + todayHtml + '</p>'); コード < script > var today = new Date (); var todayHtml = today . getFullYear () + '/' + ( today . getMonth () + 1 ) + '/' + today . getDate (); // getMonth は、1月を0としているので、+1をしている。 // document は、ブラウザが準備してくれたインスタンス。 document . write ( '<p class=\"date\">today: ' + todayHtml + '</p>' ); </ script > < style > . date { font-size : 300 % ; color : rgb ( 128 , 22 , 14 ); text-align : center ; } </ style >","tags":"JavaScript","url":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-1.html","loc":"https://iwasakishuto.github.io/Front-End/tips/JavaScript-1.html"}]};